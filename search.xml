<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>我的webpack学习（一）</title>
      <link href="/2019/10/14/%E6%88%91%E7%9A%84webpack%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2019/10/14/%E6%88%91%E7%9A%84webpack%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="一-webpack的常用配置"><a href="#一-webpack的常用配置" class="headerlink" title="一.webpack的常用配置"></a>一.webpack的常用配置</h3><h4 id="1-entry和output"><a href="#1-entry和output" class="headerlink" title="1.entry和output"></a>1.entry和output</h4><pre style="background-color:#E1F5FE;color:#01579B">    module.exports={      entry:'./src/index.js',      output:{        path:path.resolve(__dirname,'dist'),        filename:'bundle[hash:6].js',        publicPath:'http://www.baidu.com'      }    }</pre><p><span style="color:#FFB74D">&emsp;&emsp;其中entry是需要打包的文件路径，可以提供多个路径，但提供多个入口路径时，在output的输出打包文件时需要使用占位符来确保每个文件不一样。<br></span></p><a id="more"></a><h4 id="2-mode"><a href="#2-mode" class="headerlink" title="2.mode"></a>2.mode</h4><p><span style="color:#FFB74D">&emsp;&emsp;mode主要是来表明当前软件处于开发环境还是生产环境。在开发环境中可以使用devtool来进行代码的debug，可以使用webpack-dev-server开启本地便捷服务器和热替换模块。在生产环境中就将mode更改为production,在生产环境中会默认开启一些插件之类得东西，比如tree-shaking需要使用的UglifyJsPlugin插件和optimization.usedExports，同时设置配置optimization选项，设置usedExports和sideEffects为true。大概配置如下：</span></p><pre style="background-color:#E1F5FE;color:#01579B">// webpack.config.jsconst UglifyJsPlugin = require('uglifyjs-webpack-plugin');const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = {    mode: 'none',    optimization: {        minimize: true,        minimizer: [            new UglifyJsPlugin()        ],        usedExports: true,        sideEffects: true    },    plugins: [        new HtmlWebpackPlugin()    ]}</pre><span></span>#### 3.modules<span style="color:#FFB74D">&emsp;&emsp;modules主要是提供各种loader来对各种非Js模块来进行解析，常用的loader包括:<ol style="color:#CDDC39"><li> babel-loader:主要是用来将es6等代码转换为浏览器可识别的代码。</li><li>css-loader,style-loader:来打包css文件</li><li>file-loader:用来打包图片啊，啥的。</li><li>saxx-loader,scss-loader:打包css预处理器</li></ol></span>#### 4.plugins<span style="color:#FFB74D">&emsp;&emsp;插件可以看做loader的加强版，用法大概是：<pre style="background-color:#E1F5FE;color:#01579B">plugins: [    new webpack.optimize.UglifyJsPlugin(),    new HtmlWebpackPlugin({template: './src/index.html'})  ]</pre><p><span style="color:#FFB74D">&emsp;&emsp;常用的插件大概有：</span></p><p><ol style="color:#CDDC39"></ol></p><p><li><br> CommonsChunkPlugin(SplitChunksPlugin):如果把公共代码抽离成单独文件进行加载能进行优化，可以减少网络传输流量，降低服务器成本<br></li></p><p><li><br>HtmlWebpackPlugin:会将打包后的文件自动引入到html并生成新的html,也可以使用模板文件。<br></li><br><br></p></span><p></p>]]></content>
      
      
      <categories>
          
          <category> javascript&amp;es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可视化排序（二）</title>
      <link href="/2019/06/12/%E5%8F%AF%E8%A7%86%E5%8C%96%E6%8E%92%E5%BA%8F%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2019/06/12/%E5%8F%AF%E8%A7%86%E5%8C%96%E6%8E%92%E5%BA%8F%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="一-归并排序"><a href="#一-归并排序" class="headerlink" title="一.归并排序"></a>一.归并排序</h3><h4 id="1-归并排序相交于前面的排序都要复杂一些，但是他是可是在实际中被使用的排序方法。归并排序的主要思想是通过递归将数组切分到足够小，比较后交换位置后再进行合并。"><a href="#1-归并排序相交于前面的排序都要复杂一些，但是他是可是在实际中被使用的排序方法。归并排序的主要思想是通过递归将数组切分到足够小，比较后交换位置后再进行合并。" class="headerlink" title="1.归并排序相交于前面的排序都要复杂一些，但是他是可是在实际中被使用的排序方法。归并排序的主要思想是通过递归将数组切分到足够小，比较后交换位置后再进行合并。"></a>1.归并排序相交于前面的排序都要复杂一些，但是他是可是在实际中被使用的排序方法。归并排序的主要思想是通过递归将数组切分到足够小，比较后交换位置后再进行合并。</h4><h4 id="2-部分代码"><a href="#2-部分代码" class="headerlink" title="2.部分代码"></a>2.部分代码</h4><pre><code>const mergesort = function* (array) {  yield mergeSortRec(array);}///递归函数，将数组切割到足够小const mergeSortRec = (array)=&gt;{  let length = array.length;  if (length === 1) {    return array;  }  let mid = Math.floor(length / 2),    left = array.slice(0, mid),    right = array.slice(mid, length);    return merge(mergeSortRec(left), mergeSortRec(right));}//比较左右两边数组，然后合并在一起const merge = (left,right) =&gt; {  let result = [],    il = 0,    ir = 0;  while (il &lt; left.length &amp;&amp; ir &lt; right.length) {    if (left[il] &lt; right[ir]) {      result.push(left[il++]);    } else {      result.push(right[ir++]);    }  }  while (il &lt; left.length) {    result.push(left[il++]);  }  while (ir &lt; right.length) {    result.push(right[ir++]);  }  return result;}export default mergesort;</code></pre><h3 id="二-快速排序"><a href="#二-快速排序" class="headerlink" title="二.快速排序"></a>二.快速排序</h3><h4 id="1-快速排序是性能很好的排序算法了，它的主要思想类似于归并排序，但它只是在理论上切割数组，实际数组并没有被切割。最开始找到中间一个点作为主元，然后将比这个主元大的放在右边，比主元小的放在左边，这是左边和右边便可递归看成两个数组重复这个过程，切分到足够小就可以将数组的每一个元素从小到大的排列出来。"><a href="#1-快速排序是性能很好的排序算法了，它的主要思想类似于归并排序，但它只是在理论上切割数组，实际数组并没有被切割。最开始找到中间一个点作为主元，然后将比这个主元大的放在右边，比主元小的放在左边，这是左边和右边便可递归看成两个数组重复这个过程，切分到足够小就可以将数组的每一个元素从小到大的排列出来。" class="headerlink" title="1.快速排序是性能很好的排序算法了，它的主要思想类似于归并排序，但它只是在理论上切割数组，实际数组并没有被切割。最开始找到中间一个点作为主元，然后将比这个主元大的放在右边，比主元小的放在左边，这是左边和右边便可递归看成两个数组重复这个过程，切分到足够小就可以将数组的每一个元素从小到大的排列出来。"></a>1.快速排序是性能很好的排序算法了，它的主要思想类似于归并排序，但它只是在理论上切割数组，实际数组并没有被切割。最开始找到中间一个点作为主元，然后将比这个主元大的放在右边，比主元小的放在左边，这是左边和右边便可递归看成两个数组重复这个过程，切分到足够小就可以将数组的每一个元素从小到大的排列出来。</h4><h4 id="2-动图展示"><a href="#2-动图展示" class="headerlink" title="2.动图展示"></a>2.动图展示</h4><p><img src="\img\js\quick.gif" alt="图1"></p><h4 id="3-部分代码"><a href="#3-部分代码" class="headerlink" title="3.部分代码"></a>3.部分代码</h4><pre><code>const quick = function *(array, left, right) {  let index;  if (array.length &gt; 1) {    index = partition(array, left, right);//返回特定值，将左边划分为小于基准点，右边大于基准点    if (left &lt; index - 1) {      yield array      yield* quick(array, left, index - 1);//递归需使用yeild*    }    if (index &lt; right) {      yield array      yield* quick(array, index, right);    }  }}const partition = (array, left, right)=&gt; {  let pivot = array[Math.floor((right + left) / 2)],//寻找基准点    i = left,    j = right;  while (i &lt;= j) {    while (array[i] &lt; pivot) {//从左边寻找大于基准点的值      i++;    }    while (array[j] &gt; pivot) {      j--;    }    if (i &lt;= j) {      [array[i], array[j]] = [array[j], array[i]];      i++;      j--;    }  }  return i;}export default quick;</code></pre>]]></content>
      
      
      <categories>
          
          <category> javascript&amp;es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 可视化 </tag>
            
            <tag> js </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可视化排序（一）</title>
      <link href="/2019/06/11/%E5%8F%AF%E8%A7%86%E5%8C%96%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2019/06/11/%E5%8F%AF%E8%A7%86%E5%8C%96%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="一-大体介绍"><a href="#一-大体介绍" class="headerlink" title="一.大体介绍"></a>一.大体介绍</h3><h4 id="使用的排序算法包含冒泡排序，选择排序，插入排序，归并排序，快速排序，堆排序，使用echart实现部分排序的可视化排序过程，因为部分排序方法可视化太复杂。"><a href="#使用的排序算法包含冒泡排序，选择排序，插入排序，归并排序，快速排序，堆排序，使用echart实现部分排序的可视化排序过程，因为部分排序方法可视化太复杂。" class="headerlink" title="使用的排序算法包含冒泡排序，选择排序，插入排序，归并排序，快速排序，堆排序，使用echart实现部分排序的可视化排序过程，因为部分排序方法可视化太复杂。"></a>使用的排序算法包含冒泡排序，选择排序，插入排序，归并排序，快速排序，堆排序，使用echart实现部分排序的可视化排序过程，因为部分排序方法可视化太复杂。</h4><h3 id="二-冒泡排序"><a href="#二-冒泡排序" class="headerlink" title="二.冒泡排序"></a>二.冒泡排序</h3><h4 id="1-冒泡排序的主要思想是通过二重for循环，循环比较相邻两项，按照统一的大小排列顺序进行交换位置，性能较差，复杂度为-O-n-2-。"><a href="#1-冒泡排序的主要思想是通过二重for循环，循环比较相邻两项，按照统一的大小排列顺序进行交换位置，性能较差，复杂度为-O-n-2-。" class="headerlink" title="1.冒泡排序的主要思想是通过二重for循环，循环比较相邻两项，按照统一的大小排列顺序进行交换位置，性能较差，复杂度为      O(n^2)。"></a>1.冒泡排序的主要思想是通过二重for循环，循环比较相邻两项，按照统一的大小排列顺序进行交换位置，性能较差，复杂度为      O(n^2)。</h4><h4 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2.代码实现"></a>2.代码实现</h4><h5 id="1）可视化方面选用echart的柱状图。"><a href="#1）可视化方面选用echart的柱状图。" class="headerlink" title="1）可视化方面选用echart的柱状图。"></a>1）可视化方面选用echart的柱状图。</h5><h5 id="2）因为要将每一个排序后的数组状态保存下来，形成一个动态的动画效果，就可以使用Generator和yield配合setInterval来进行实现。"><a href="#2）因为要将每一个排序后的数组状态保存下来，形成一个动态的动画效果，就可以使用Generator和yield配合setInterval来进行实现。" class="headerlink" title="2）因为要将每一个排序后的数组状态保存下来，形成一个动态的动画效果，就可以使用Generator和yield配合setInterval来进行实现。"></a>2）因为要将每一个排序后的数组状态保存下来，形成一个动态的动画效果，就可以使用Generator和yield配合setInterval来进行实现。</h5><a id="more"></a><h4 id="3-动图展示"><a href="#3-动图展示" class="headerlink" title="3.动图展示"></a>3.动图展示</h4><p><img src="\img\js\maopao.gif" alt="图1"></p><h4 id="4-部分代码"><a href="#4-部分代码" class="headerlink" title="4.部分代码"></a>4.部分代码</h4><p>使用的vue框架，完整代码在 <a href="https://github.com/Qian4321/sort-v" target="_blank" rel="noopener">https://github.com/Qian4321/sort-v</a></p><pre><code>const bubble = function* (array) {  let length = array.length;  for (let i = 0; i &lt; length; i++) {    for (let j = 0; j &lt; length - 1-i; j++) {      if (array[j] &gt; array[j + 1]) {        [array[j], array[j + 1]] = [array[j + 1], array[j]];        yield array;      }    }  }}export default bubble;</code></pre><p>调用代码：</p><pre><code>bubble_click(){    let chart = bar.myChart(&quot;main&quot;);    let option = bar.option;    let array = bubble([60, 89, 23, 78, 36,42,72,19,49,73,48]);    let arr;    option.title.text = &quot;冒泡排序&quot;;   let dosort= setInterval(() =&gt; {     arr = array.next();     if (arr.done == true) {       clearInterval(dosort);       return;     }     option.xAxis.data = arr.value;     option.series[0].data = arr.value;     chart.setOption(option);   }, 500)  }</code></pre><h3 id="三-选择排序"><a href="#三-选择排序" class="headerlink" title="三.选择排序"></a>三.选择排序</h3><h4 id="1-选择排序主要思想也是通过双层for循环，与冒泡不同的是他不会将相邻的项交换位置，而是直接间接交换最大值或最小值到指定的位置。复杂度也是O-n-2-。"><a href="#1-选择排序主要思想也是通过双层for循环，与冒泡不同的是他不会将相邻的项交换位置，而是直接间接交换最大值或最小值到指定的位置。复杂度也是O-n-2-。" class="headerlink" title="1.选择排序主要思想也是通过双层for循环，与冒泡不同的是他不会将相邻的项交换位置，而是直接间接交换最大值或最小值到指定的位置。复杂度也是O(n^2)。"></a>1.选择排序主要思想也是通过双层for循环，与冒泡不同的是他不会将相邻的项交换位置，而是直接间接交换最大值或最小值到指定的位置。复杂度也是O(n^2)。</h4><h4 id="2-代码实现-1"><a href="#2-代码实现-1" class="headerlink" title="2.代码实现"></a>2.代码实现</h4><h5 id="与冒泡类似"><a href="#与冒泡类似" class="headerlink" title="与冒泡类似"></a>与冒泡类似</h5><h4 id="3-动图展示-1"><a href="#3-动图展示-1" class="headerlink" title="3.动图展示"></a>3.动图展示</h4><p><img src="\img\js\selection.gif" alt="图2"></p><h4 id="4-部分代码-1"><a href="#4-部分代码-1" class="headerlink" title="4.部分代码"></a>4.部分代码</h4><pre><code>const selection = function* (array) {  let length = array.length;  for (let i = 0; i &lt; length - 1; i++) {    let max = array[0];    let index = 0;    for (let j = 1; j &lt;= length - 1 - i; j++) {      if (array[j] &gt; max) {        max = array[j];        index = j;      }    }    [array[index], array[length - 1 - i]] = [array[length - 1 - i], array[index]];    yield array;  }}export default selection;</code></pre><h3 id="四-插入排序"><a href="#四-插入排序" class="headerlink" title="四.插入排序"></a>四.插入排序</h3><h4 id="1-插入排序主要是将数组第一位看成是已经排序好的，然后将后面的项插入到已经排列好的序列中。性能比冒泡和选择要好。"><a href="#1-插入排序主要是将数组第一位看成是已经排序好的，然后将后面的项插入到已经排列好的序列中。性能比冒泡和选择要好。" class="headerlink" title="1.插入排序主要是将数组第一位看成是已经排序好的，然后将后面的项插入到已经排列好的序列中。性能比冒泡和选择要好。"></a>1.插入排序主要是将数组第一位看成是已经排序好的，然后将后面的项插入到已经排列好的序列中。性能比冒泡和选择要好。</h4><h4 id="2-动图展示"><a href="#2-动图展示" class="headerlink" title="2.动图展示"></a>2.动图展示</h4><p><img src="\img\js\insertion.gif" alt="图3"></p><h4 id="3-部分代码"><a href="#3-部分代码" class="headerlink" title="3.部分代码"></a>3.部分代码</h4><pre><code>const insertion = function* (array) {  let length = array.length,      j, temp;  for (let i = 1; i &lt; length; i++) {    j = i;    temp = array[i];    while (j &gt; 0 &amp;&amp; temp &lt; array[j - 1]) {      array[j] = array[j - 1];      j--;    }    array[j] = temp;    yield array;  }}export default insertion;</code></pre>]]></content>
      
      
      <categories>
          
          <category> javascript&amp;es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 可视化 </tag>
            
            <tag> js </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js数据结构-字典和散列表</title>
      <link href="/2019/05/07/js%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8%E5%92%8C%E6%95%A3%E5%88%97%E8%A1%A8/"/>
      <url>/2019/05/07/js%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8%E5%92%8C%E6%95%A3%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="一-字典"><a href="#一-字典" class="headerlink" title="一.字典"></a>一.字典</h3><p>和集合不同的是，字典使用[键，值]的形式来储存值，键是唯一的，也就可以保证储存的是惟一值。ps:字典也被称为映射。在es6中可以用map来进行字典操作。</p><h4 id="1-1创建字典"><a href="#1-1创建字典" class="headerlink" title="1.1创建字典"></a>1.1创建字典</h4><p>字典中包含以下方法(根据es6的Map)：set(key,value)-添加新元素（那为什么不使用add），delete(key)-根据键值删除数据，has(key)-判断键值是否存在于字典中，get(key)-根据键值获取值，clear()-清除所有值，size()-返回元素的数量，keys()-将字典的键值以数组形式返回，values()-将字典的数值以数组形式返回。<br><a id="more"></a></p><h4 id="1-2具体代码"><a href="#1-2具体代码" class="headerlink" title="1.2具体代码"></a>1.2具体代码</h4><pre><code>class Dictionary {  constructor() {    this.items = {};  }  //添加值  set(key, value) {    Reflect.set(this.items, key, value);  }  //判断值是否存在  has(key) {    return Reflect.has(this.items, key);  }  //删除值  delete(key) {    if (this.has(key)) {      Reflect.deleteProperty(this.items, key);      return true;    }    else {      return false;    }  }  //获取值  get(key) {    if (this.has(key)) {      return Reflect.get(this.items, key);    }    else {      return false;    }  }  //清空字典  clear() {    this.items = {};  }  //返回字典长度  size() {    return Reflect.ownKeys(this.items).length;  }  //返回Key数组  keys() {    return Reflect.ownKeys(this.items);  }  //返回所有值  values() {    let keys = this.keys();    let values=[];    for (let key of keys) {      values.push(this.get(key));    }    return values;  }  //打印所有{key,value}  print() {    console.log(&quot;打印所有元素&quot;);    let keys = this.keys();    let values = this.values();    for (let i = 0; i &lt; keys.length;i++ ) {      console.log(&quot;{&quot; + keys[i] + &quot;,&quot; + values[i] + &quot;}&quot;);    }  }}module.exports = Dictionary;</code></pre><p>在这里为了适应es6将很多Object中的函数使用Reflect来代替，其中大多数改变不大，只有in和delete的使用方法有较大改变。具体代码较简单。</p><h3 id="二-散列表"><a href="#二-散列表" class="headerlink" title="二.散列表"></a>二.散列表</h3><p>散列表又名HashTable(HashMap),是Dictionary类的一种散列表实现方式。具体就是将键值装化为一个哈希值，存储在数组对应哈希值的地方，但有可能会出现哈希冲突，所以需要更多的方法来减小哈希冲突。优势:实现了随机访问，所以性能比较快，但是对于散列函数的设计要求比较高，而且设计需要根据自己的需求进行设计，实现高访问。</p><h4 id="2-1-创建散列表"><a href="#2-1-创建散列表" class="headerlink" title="2.1 创建散列表"></a>2.1 创建散列表</h4><p>散列表的方法较少，put(key.value)-向散列表中添加一个新值，remove(key)-在散列表中移除一个，get(key)-获取值。</p><h4 id="2-2-具体代码"><a href="#2-2-具体代码" class="headerlink" title="2.2 具体代码"></a>2.2 具体代码</h4><pre><code>class HashTable {  constructor() {    this.table = [];    //获取key的哈希值,ps:要尽量减少冲突    this.loseloseHashCode = function (key) {      let hash = 0;      for (let char of key) {        hash =char.charCodeAt();      }      return hash % 37;    }  }  //添加元素  put(key, value) {    let hash = this.loseloseHashCode(key);    this.table[hash] = value;  }  //移除元素  remove(key) {    let hash = this.loseloseHashCode(key);    this.table[hash] = undefined;  }  //获取值  get(key) {    let hash = this.loseloseHashCode(key);    return this.table[hash];  }}module.exports = HashTable;</code></pre><p>回忆：for..of循环可以使用的范围包括数组，Set和Map结构，某些类似数组的对象，Generator对象，以及字符串。但上面的代码会很容易出现Hash冲突，即hash的值很容易一样，这样就会导致后添加的值替换前面的，出现错误。</p><h4 id="2-3-处理哈希冲突的三种方法"><a href="#2-3-处理哈希冲突的三种方法" class="headerlink" title="2.3 处理哈希冲突的三种方法"></a>2.3 处理哈希冲突的三种方法</h4><h5 id="2-3-1-分离链接"><a href="#2-3-1-分离链接" class="headerlink" title="2.3.1 分离链接"></a>2.3.1 分离链接</h5><p>通过前面学习的链表，将hash值对应的数组位置指向一个链表的head,然后若出现重复的hash值就直接将值挂靠到链表后面。</p><h5 id="2-3-2-线性探查"><a href="#2-3-2-线性探查" class="headerlink" title="2.3.2 线性探查"></a>2.3.2 线性探查</h5><p>将出现重复的哈希值依次瞬移到空白的位置，个人感觉很蠢。</p><h5 id="2-3-3-创建更好的散列函数"><a href="#2-3-3-创建更好的散列函数" class="headerlink" title="2.3.3 创建更好的散列函数"></a>2.3.3 创建更好的散列函数</h5><pre><code>this.loseloseHashCode = function (key) {  let hash = 5381;//常用质数  for (let char of key) {    hash =hash*33+char.charCodeAt();  }  return hash % 1031;}</code></pre><p>这是改良后的生成哈希值的算法，虽然我不懂原理，但这只是降低了出现冲突的概率，并不能完全消灭。</p>]]></content>
      
      
      <categories>
          
          <category> js数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 字典 </tag>
            
            <tag> 散列表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js数据结构--链表</title>
      <link href="/2019/05/06/js%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/05/06/js%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="一-链表数据结构"><a href="#一-链表数据结构" class="headerlink" title="一.链表数据结构"></a>一.链表数据结构</h3><pre><code>链表储存有序的元素集合，但不同于数组，链表中的元素在内存中不是连续放置的。每个元素有一个储存元素本身的节点和指向下一个元素的引用组成。</code></pre><p><img src="\img\DataStructures\链表1_1.png" alt="图1.1 来自百度百科"></p><h3 id="二-创建链表"><a href="#二-创建链表" class="headerlink" title="二.创建链表"></a>二.创建链表</h3><p>在这里采用es6的class语法糖进行创建LinkedList类，该类包含append方法–向链表中添加元素到末尾，insert方法–向链表中插入一个元素，remove方法–移除一个元素，indexof方法–返回元素在列表中的属性，removeAt–从链表中移除特定位置的一项，isEmpty–看链表是否为空，size–获取链表长度。<br><a id="more"></a></p><h4 id="1-整体框架"><a href="#1-整体框架" class="headerlink" title="1.整体框架"></a>1.整体框架</h4><pre><code>class LinkedList {  constructor() {    this.length = 0;//标识链表的长度    this.head = null;//标识头结点    this.node = function (element) {      this.element = element;      this.next = null;     }   }   //具体方法...   append(element) {}   insert(position,element){}   //还有许多方法... }</code></pre><p>在类的构造函数内定义基本变量，其中定义了一个node类，目的是将传入的元素储存在其中，并与next属性相绑定。</p><h4 id="2-append方法"><a href="#2-append方法" class="headerlink" title="2.append方法"></a>2.append方法</h4><p>在创建append方法前，要考虑链表是否为空的情况，若为空，则直接添加，若不为空，则遍历链表将其放置到末尾。</p><pre><code>//向链表中添加元素append(element) {  let node =new this.node(element);  let current;//一个用于遍历的中间变量  if (this.length == 0) {    this.head = node;//如果链表为空，则将添加的node设置为头结点  }  else {    current = this.head;    while (current.next) {//找到最后的子节点        current = current.next;    }    current.next = node;  }    this.length++;}</code></pre><h4 id="3-insert方法"><a href="#3-insert方法" class="headerlink" title="3.insert方法"></a>3.insert方法</h4><p>insert方法有两个参数，一个是要插入的位置，一个是要插入的元素。过于插入的位置从0开始，若为0则插入到最前面，以此类推。在插入时首先要根据进行position的判断，看是否越界。对于position是否为0也要有对于的处理方法。</p><pre><code>//向列表中插入元素insert(position,element) {  if (position &gt;= 0 &amp;&amp; position &lt; this.length) {    let node = new this.node(element);    let index = 1;    let current;    //添加到首部    if (position == 0) {      node.next = this.head;      this.head = node;    }    else {      current = this.head;      while (index++ &lt; position) {        current = current.next;      }      node.next = current.next;      current.next = node;      }      this.length++;    }else {    return false;   }}</code></pre><h4 id="4-remove方法"><a href="#4-remove方法" class="headerlink" title="4.remove方法"></a>4.remove方法</h4><p>实现remove方法要先判断该元素是否存在，由于可能出现重复的情况，所以只删掉离head最近的元素。</p><pre><code>//从列表中移除元素,移除对应element出现第一次的node,后面的重复不管，若要移除全部，可配合indexof方法进行删除remove(element) {  let current = this.head;  let exit = false;//判断该element是否存在  while (current.next) {    if (current.next.element == element) {      exit = true;      break;    }    current = current.next;  }  if (exit == true) {    if (current.next.next == null) {//为null说明被删除元素是最后一个      current.next = null;    }    else {      current.next = current.next.next;    }  }  else {    return false;  }  this.length--;}</code></pre><h4 id="5-indexof方法"><a href="#5-indexof方法" class="headerlink" title="5.indexof方法"></a>5.indexof方法</h4><p>同样有可能出现重复的元素情况，所以若查找的元素存在就返回离head最近的index,若不存在就返回-1。</p><pre><code>//返回元素的索引,若不存在则返回-1,索引从0开始indexof(element) {  let current = this.head;  let index = 0;  while (current.next) {//这种判断方法忽略了最后一个node    if (current.element == element) {      return index;    }    index++;    current = current.next;  }  //判断最后一个node  if (current.element == element) {    return length - 1;  }  else {//若最后一个元素都不满足条件，则可判断不存在这个元素    return -1;  }}</code></pre><h4 id="6-print方法"><a href="#6-print方法" class="headerlink" title="6.print方法"></a>6.print方法</h4><p>该方法是打印出所有node的element属性。</p><pre><code>//打印所有成员print() {  if (this.length == 0) {    console.log(&quot;链表长度为0&quot;)  }  else {    let current = this.head    while (current.next) {      console.log(current.element);      current = current.next;    }    console.log(current.element);  }}</code></pre><h4 id="7-其他方法就简单，只贴代码"><a href="#7-其他方法就简单，只贴代码" class="headerlink" title="7.其他方法就简单，只贴代码"></a>7.其他方法就简单，只贴代码</h4><pre><code>//判断该链表是否为空,直接判断head是否为空isEmpty() {  if (this.head) {    return true;  }  else {    return false;  }}//返回链表长度size() {  return this.length;}</code></pre><h3 id="三-测试"><a href="#三-测试" class="headerlink" title="三.测试"></a>三.测试</h3><p>将类模块导出去，然后在主代码里运行。</p><pre><code>//测试数据结构const Linked = require(&apos;./LinkedList/Linked&apos;);let mylink = new Linked();mylink.print();mylink.append(1);mylink.append(2);mylink.append(3);mylink.print();console.log(&quot;插入&quot;)mylink.insert(2, 99);mylink.print();console.log(&quot;移除&quot;)mylink.remove(2);mylink.remove(99);mylink.print();console.log(&quot;获取长度&quot;);console.log(mylink.size());console.log(&quot;获取索引&quot;);console.log(mylink.indexof(3));console.log(&quot;获取长度&quot;);console.log(mylink.size());</code></pre><p>结果如下图：<br><img src="\img\DataStructures\链表1_2.jpg" alt="图1.2"></p>]]></content>
      
      
      <categories>
          
          <category> js数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js阶段学习（二）</title>
      <link href="/2019/04/28/js%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2019/04/28/js%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="二-函数上下文和-amp-执行上下文-amp-作用域"><a href="#二-函数上下文和-amp-执行上下文-amp-作用域" class="headerlink" title="二.函数上下文和&amp;执行上下文&amp;作用域"></a>二.函数上下文和&amp;执行上下文&amp;作用域</h2><h3 id="1-函数上下文"><a href="#1-函数上下文" class="headerlink" title="1.函数上下文"></a>1.函数上下文</h3><p>函数上下文就是常见的this,this的值是可变的，在调用函数的时候才能确定this的值。而函数的调用也很多种方式，对应的this取值规则也都不一样。<br><a id="more"></a></p><h4 id="1-1-通过函数直接调用"><a href="#1-1-通过函数直接调用" class="headerlink" title="1.1 通过函数直接调用"></a>1.1 通过函数直接调用</h4><p>无论是函数声明还是函数表达式，如果是作为函数被直接调用，那么它的函数上下文是windows,在严格模式下是undefined。</p><h4 id="1-2-作为方法被调用"><a href="#1-2-作为方法被调用" class="headerlink" title="1.2 作为方法被调用"></a>1.2 作为方法被调用</h4><p>当函数被当做对象的属性被调用时，此时的函数上下文指的就是调用函数对象。</p><h4 id="1-3-作为构造函数调用"><a href="#1-3-作为构造函数调用" class="headerlink" title="1.3 作为构造函数调用"></a>1.3 作为构造函数调用</h4><p>1）构造函数如果返回的是非对象类型，则直接忽略返回值，将创建得函数作为函数上下文。<br>2）构造函数返回的是对象，则将返回的对象作为整个表达式的值返回，传入的this无效。</p><h4 id="1-4-使用apply和call方法调用"><a href="#1-4-使用apply和call方法调用" class="headerlink" title="1.4 使用apply和call方法调用"></a>1.4 使用apply和call方法调用</h4><p>apply和call方法都是定义在Function方法的原型对象中，所以普通的方法也可以使用。apply和call可以自己选择传入一个对象作为函数上下文。</p><h4 id="1-5-使用箭头函数忽略this"><a href="#1-5-使用箭头函数忽略this" class="headerlink" title="1.5 使用箭头函数忽略this"></a>1.5 使用箭头函数忽略this</h4><p>调用箭头函数时，不会传入this参数，而是从定义时函数继承上下文。</p><h3 id="2-执行上下文"><a href="#2-执行上下文" class="headerlink" title="2.执行上下文"></a>2.执行上下文</h3><p>在js中，代码的执行基础单元是函数，每当发生函数调用，都会出现执行上下文的改变。全局代码对应的是全局执行上下文，函数代码对应的是执行上下文。当代码开始运行时，首先将全局执行上下文入栈（调用栈），调用其他函数后将该函数入栈，全局执行上下文暂停，运行该函数的执行上下文。按此规律，所有函数进行入栈出栈。</p><h3 id="3-作用域（语法环境）"><a href="#3-作用域（语法环境）" class="headerlink" title="3.作用域（语法环境）"></a>3.作用域（语法环境）</h3><p>在执行上下文入栈的时候，会创建一个与之对应的作用域环境，并在该函数的内置[[Environment]]属性上与上一个入栈的作用域环境。</p>]]></content>
      
      
      <categories>
          
          <category> javascript&amp;es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js阶段学习（一）</title>
      <link href="/2019/04/26/js%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2019/04/26/js%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一-面向对象"><a href="#一-面向对象" class="headerlink" title="一.面向对象"></a>一.面向对象</h2><h3 id="1-闭包"><a href="#1-闭包" class="headerlink" title="1.闭包"></a>1.闭包</h3><pre><code>闭包的作用在我看来就是将创建的函数对象包裹起来，有着独立的变量，作用域，并且保护函数中的变量。接近c#中的对象概念，每个对象之间都是独立的。闭包的具体作用大概可以有两种：1)封装私有变量：js不支持私有变量，但可以在函数中声明变量，来达到一个类似私有变量的效果。2）就是类似对象，可以很好的使用一个函数生成许多实例，并且实例互不影响，达到代码复用。</code></pre><a id="more"></a><h3 id="2-原型链"><a href="#2-原型链" class="headerlink" title="2.原型链"></a>2.原型链</h3><pre><code>首先知道js中对象都是有函数产生的，而函数是一种特殊的对象。所以就有一个叫Function的函数它自己生成了自己。所有的对象都有一个叫_proto_的隐藏属性，该属性指向生成该函数的原型对象。所以Function函数的_proto_属性指向的是自己的原型对象。而其他函数都是由Function函数生成的，所以它们的_proto_属性指向的也是Function的原型对象。那既然函数是由Function函数生成的，对象便是由Object函数生成的。这个Object函数是由Function函数生成的，所以它的_proto_属性指向也就是Function函数对应的原型。而这个Object函数的作用就是生成出来函数的对象。前面说到每个对象都有_proto_属性指向生成函数的原型对象，既然是对象，那么它也有属于自己的_proto_属性。因为对象是由Object函数生成的，所以的_proto_属性指向的就是Object函数的原型对象，而Object函数的原型对象就指向null。这样通过_proto_属性就构成了原型链。</code></pre><h3 id="3-继承"><a href="#3-继承" class="headerlink" title="3.继承"></a>3.继承</h3><pre><code>各个对象之间是由_proto_进行串联起来的。比如利用构造函数Function创建了一个普通对象obj1，那么该对象的_proto_指向构造函数的原型对象。而该原型对象的_proto_就指向Object函数的原型对象，然后指向null。所以通过继承可以在这个新建的普通函数中使用构造函数的原型对象的方法和Object函数的原型对象的方法。这是本来就有的继承。所以如果再定义一个对象obj2来继承前面写的obj1对象，那么就只需要将obj2的构造函数的原型对象设置为obj1，便可以通过原型链访问到obj1中的方法和obj1的_proto_中的方法。但需要注意的是，应该要让在改变obj2的构造函数的propotype指向obj1后，obj1的constructor属性也要指向obj2的构造函数。</code></pre><p>下面是反应函数与对象之间关系的图：<br><img src="\img\js\继承关系.png" alt="js"><br>图片来源：<a href="https://www.cnblogs.com/wangfupeng1988/p/3979533.html" target="_blank" rel="noopener">https://www.cnblogs.com/wangfupeng1988/p/3979533.html</a></p>]]></content>
      
      
      <categories>
          
          <category> javascript&amp;es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack arcgis api for js</title>
      <link href="/2019/03/18/webpack-arcgis-api-for-js/"/>
      <url>/2019/03/18/webpack-arcgis-api-for-js/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;将arcgis api for js 与webpack结合起来对于我来说确实比较难，但其中dojo也要承担大部分的责任。arcgis api for js采用dojo进行开发，但我感觉dojo也快不行了，在webpack中水土不服。估计Esri也感觉不好意思，开发了esri-loader来进行辅助。这里采用的也是esri-loader。<br><a id="more"></a></p><h2 id="一-使用步骤"><a href="#一-使用步骤" class="headerlink" title="一.使用步骤"></a>一.使用步骤</h2><h3 id="1-安装依赖包"><a href="#1-安装依赖包" class="headerlink" title="1.安装依赖包"></a>1.安装依赖包</h3><ul><li>esri-loader(关键包)</li><li>express(框架)</li><li>http-proxy-middleware(node来处理跨域的包，究极好用)</li><li><p>babel全家桶(处理es6代码)</p><h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;在webpack的entry文件中导入esri-loader包。</p><p> import esriLoader from ‘esri-loader’;<br>然后加载在线的js api和css文件，这里建议将js api 布置在本地，避免一些不必要的麻烦。关于将js api布置在本地可以参考这一篇博客：<a href="https://blog.csdn.net/qq_35117024/article/details/82633084" target="_blank" rel="noopener">本地部署</a>。部署完了可以参考以下代码加载</p><p> esriLoader.loadCss(‘<a href="http://127.0.0.1:3001/arcgis_js_api/library/4.9/esri/css/main.css&#39;)" target="_blank" rel="noopener">http://127.0.0.1:3001/arcgis_js_api/library/4.9/esri/css/main.css&#39;)</a>;<br> const options = {<br>  url:’<a href="http://127.0.0.1:3001/arcgis_js_api/library/4.9/dojo/dojo.js&#39;" target="_blank" rel="noopener">http://127.0.0.1:3001/arcgis_js_api/library/4.9/dojo/dojo.js&#39;</a><br> };<br>加载完毕后就可以进行开发了。</p><h3 id="3-开发"><a href="#3-开发" class="headerlink" title="3.开发"></a>3.开发</h3><h4 id="3-1-js部分代码"><a href="#3-1-js部分代码" class="headerlink" title="3.1 js部分代码"></a>3.1 js部分代码</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;代码如下：</p></li></ul><pre><code>&gt;加载函数&gt;esriLoader.loadModules([    &quot;esri/Map&quot;,    &quot;esri/Ground&quot;,    &quot;esri/layers/ElevationLayer&quot;,    &quot;esri/config&quot;,    &quot;esri/views/SceneView&quot;,    &quot;esri/geometry/Extent&quot;,    &quot;dojo/domReady&quot;],options)    .then(([Map,Ground,ElevationLayer,esriConfig,SceneView,Extent]) =&gt; {        esriConfig.request.corsEnabledServers.push(&quot;localhost:6080&quot;);//设   置地图服务器已允许跨域        var customElevation = ElevationLayer({            url: &quot;http://localhost:6080/arcgis/rest/services//SiChuan/suining/MapServer&quot;        });        var map = new Map({            // basemap: &quot;streets&quot;,//ESRI提供的底 图            basemap: &quot;hybrid&quot;,//ESRI提供的影像图            //  ground: &quot;world-elevation&quot;//ESRI提供的全球地形            ground: new Ground({                layers: [ customElevation ]            })        });        var view=new SceneView({            map:map,            container: &quot;viewDiv&quot;        });        view.ui.remove(&quot;attribution&quot;);//移除底部ESRI logo        view.when(function () {            view.goTo({                position: {                    x: 113.642578125,                    y: 34.7222900390625,                    z: 700,                    spatialReference: {                        wkid: 4326                    }                },                heading: 50,                tilt: 80            }, {                speedFactor: 0.7            });        }).catch(function (reason) {            console.log(reason)    })}).catch(err =&gt; {// handle any script or module loading errorsconsole.error(err);});</code></pre><p>可以看出它的使用代码和原始的使用方法差不多，只是有一些加载上的不同。然后就可以愉快的打包了。</p><h4 id="3-2-html部分代码"><a href="#3-2-html部分代码" class="headerlink" title="3.2 html部分代码"></a>3.2 html部分代码</h4><pre><code>&gt; &lt;!DOCTYPE html&gt;&gt; &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt;    &lt;title&gt;第一个地图应用&lt;/title&gt;    &lt;style&gt;    html,    body,    #viewDiv {    padding: 0;    margin: 0;    height: 100%;    width: 100%;    }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;script src=&quot;/javascripts/bundle.js&quot;&gt;&lt;/script&gt;    &lt;div id=&quot;viewDiv&quot; &gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>Tips:注意这里的id和css代码，别搞错了。bundle.js是打包生成的文件，要放在boby标签里。</p><h4 id="3-3-关于跨域的问题"><a href="#3-3-关于跨域的问题" class="headerlink" title="3.3 关于跨域的问题"></a>3.3 关于跨域的问题</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;我开始也是想在布置本地api的时候就按照网上的解决方法设置跨域，但弄了很久，经历了从入门到放弃。然后决定直接在后端进行转发，而使用node.js的express的中间件http-proxy-middleware就十分方便了。这个中间件的用处十分强大，在这里就只使用它的一小部分功能。</p><pre><code>let app = express();let proxy = require(&apos;http-proxy-middleware&apos;);let apiProxyJs = proxy({target: &apos;http://192.168.0.104/&apos;,changeOrigin : true});app.use(&apos;/arcgis_js_api&apos;, apiProxyJs);</code></pre><p>大概意思就是请求的url里面路径是’/arcgis_js_api’开头的，都改变它的主机。我这里就的http请求是’<a href="http://127.0.0.1:3001/arcgis_js_api/library/4.9/dojo/dojo.js&#39;，经过转发就是&#39;http://http://192.168.0.104/arcgis_js_api/library/4.9/dojo/dojo.js&#39;。使用的时候要变成自己的路径。" target="_blank" rel="noopener">http://127.0.0.1:3001/arcgis_js_api/library/4.9/dojo/dojo.js&#39;，经过转发就是&#39;http://http://192.168.0.104/arcgis_js_api/library/4.9/dojo/dojo.js&#39;。使用的时候要变成自己的路径。</a><br>(完结撒花)</p>]]></content>
      
      
      <categories>
          
          <category> arcgis api for js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
            <tag> webgis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我</title>
      <link href="/2019/03/17/%E6%88%91/"/>
      <url>/2019/03/17/%E6%88%91/</url>
      
        <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="Welcome to my blog, enter password to read." />    <label for="pass">Welcome to my blog, enter password to read.</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>R语言空间信息挖掘（三）</title>
      <link href="/2019/03/16/R%E8%AF%AD%E8%A8%80%E7%A9%BA%E9%97%B4%E4%BF%A1%E6%81%AF%E6%8C%96%E6%8E%98%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2019/03/16/R%E8%AF%AD%E8%A8%80%E7%A9%BA%E9%97%B4%E4%BF%A1%E6%81%AF%E6%8C%96%E6%8E%98%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="一-实验要求"><a href="#一-实验要求" class="headerlink" title="一.实验要求"></a>一.实验要求</h3><pre><code>经过前面的学习，我觉得我可以完成老师所布置的第一次作业了。这次的作业要求大概如下：老师提供csv文件，其中格式为</code></pre><table><thead><tr><th>uid</th><th>gpa</th><th>4月1日</th><th>4月2日</th></tr></thead><tbody><tr><td>15</td><td>3.45</td><td>34</td><td>37</td></tr><tr><td>18</td><td>2.45</td><td></td><td>33</td></tr></tbody></table><a id="more"></a><pre><code>大致意思就是记录该学号(uid)在某天某节课上课时坐的位置编号，gpa为成绩。实验的目的就是通过可视化计算出gpa比较好的同学在教室里是聚集分布还是均匀分布或是随机分布。</code></pre><h3 id="二-实验思路"><a href="#二-实验思路" class="headerlink" title="二.实验思路"></a>二.实验思路</h3><h4 id="1-导入数据，进行数据的预处理，即是将本节课没有来的同学去除掉。"><a href="#1-导入数据，进行数据的预处理，即是将本节课没有来的同学去除掉。" class="headerlink" title="1.导入数据，进行数据的预处理，即是将本节课没有来的同学去除掉。"></a>1.导入数据，进行数据的预处理，即是将本节课没有来的同学去除掉。</h4><h4 id="2-进行数据处理，将座位编号转化为在二维上的点坐标。"><a href="#2-进行数据处理，将座位编号转化为在二维上的点坐标。" class="headerlink" title="2.进行数据处理，将座位编号转化为在二维上的点坐标。"></a>2.进行数据处理，将座位编号转化为在二维上的点坐标。</h4><h4 id="3-将生成的二维坐标与uid-gpa联系起来生成SpatialPointDataFrame。"><a href="#3-将生成的二维坐标与uid-gpa联系起来生成SpatialPointDataFrame。" class="headerlink" title="3.将生成的二维坐标与uid,gpa联系起来生成SpatialPointDataFrame。"></a>3.将生成的二维坐标与uid,gpa联系起来生成SpatialPointDataFrame。</h4><h4 id="4-将SpatialPointDataFrame转化为SpatialPixelsDataFrame，然后进行绘图。"><a href="#4-将SpatialPointDataFrame转化为SpatialPixelsDataFrame，然后进行绘图。" class="headerlink" title="4.将SpatialPointDataFrame转化为SpatialPixelsDataFrame，然后进行绘图。"></a>4.将SpatialPointDataFrame转化为SpatialPixelsDataFrame，然后进行绘图。</h4><h4 id="5-分别采用样方法和聚类法进行分析。"><a href="#5-分别采用样方法和聚类法进行分析。" class="headerlink" title="5.分别采用样方法和聚类法进行分析。"></a>5.分别采用样方法和聚类法进行分析。</h4><h3 id="三-具体实验步骤-代码"><a href="#三-具体实验步骤-代码" class="headerlink" title="三.具体实验步骤(代码)"></a>三.具体实验步骤(代码)</h3><h4 id="1-定义变量，便于后期修改数据"><a href="#1-定义变量，便于后期修改数据" class="headerlink" title="1.定义变量，便于后期修改数据"></a>1.定义变量，便于后期修改数据</h4><pre><code>library(sp)#定义变量xnum&lt;-10#每行有多少个座位bestgpa&lt;-3#定义多少gpa为优秀学生date&lt;-&quot;X4月11日&quot;#定义截取的日期</code></pre><h4 id="2-读取数据，过滤数据"><a href="#2-读取数据，过滤数据" class="headerlink" title="2.读取数据，过滤数据"></a>2.读取数据，过滤数据</h4><pre><code>#读取数据data=read.csv(&quot;F:/google下载/seat.csv&quot;,header=TRUE)#读取数据fdata=data[c(&quot;uid&quot;,&quot;gpa.all&quot;,date)]#选取4月9日的数据fdata=fdata[complete.cases(fdata),]#过滤数据为NA的行</code></pre><p>获取seat.csv文件的链接链接：<a href="https://pan.baidu.com/s/16XKNH-uGwOEyV1E1gcLpgA" target="_blank" rel="noopener">https://pan.baidu.com/s/16XKNH-uGwOEyV1E1gcLpgA</a> ,提取码：osc4 </p><h4 id="3-创建SpatialPixelsDataFrame"><a href="#3-创建SpatialPixelsDataFrame" class="headerlink" title="3.创建SpatialPixelsDataFrame"></a>3.创建SpatialPixelsDataFrame</h4><pre><code>#创建SpatialPointsseat&lt;-fdata[3]#获取座位编号num&lt;-nrow(seat)#获取需要创建的座位个数seat1&lt;-coordinates(cbind(x=seat[(1:num),1]%%xnum+1,y=seat[(1:num),1]%/%xnum+1))#生成座位seat2&lt;-SpatialPoints(seat1)seat3&lt;-SpatialPointsDataFrame(seat2,fdata[c(&quot;gpa.all&quot;)])seat4&lt;-as(seat3,&quot;SpatialPixelsDataFrame&quot;)#强制转化为SpatialPixelsDataFramespplot(subset(seat4,gpa.all&gt;=bestgpa))</code></pre><p>最后一行spplot中的过滤条件改变bestgpa来改变展示的座位。<br><img src="\img\R与空间分析_img\3-1.jpeg" alt="图3.1"></p><h4 id="4-样方法分析"><a href="#4-样方法分析" class="headerlink" title="4.样方法分析"></a>4.样方法分析</h4><h5 id="4-1-划定样方大小"><a href="#4-1-划定样方大小" class="headerlink" title="4.1 划定样方大小"></a>4.1 划定样方大小</h5><pre><code>生成图为10X8的大小，可以划分为2X2的区域，也可以有其他的划分方法。这也是样方的缺点之一，样方的确定对实验结果的影响特别大。</code></pre><h5 id="4-2-计算均值与方差"><a href="#4-2-计算均值与方差" class="headerlink" title="4.2 计算均值与方差"></a>4.2 计算均值与方差</h5><pre><code>规则：对于均匀分布，方差=0，因此VMR的期望值= 0；对于随机分布，方差=均值，因此VMR的期望值= 1；对于聚集分布，方差大于均值。因此VMR的期望值 &gt;1 #样方法的计算，样方大小为2X2,本次实验采取手工读数，不采取包的方式area&lt;-c(2,1,0,1,0,0,0,1,0,1,2,0,2,0,1,2,1,2,2,1)#每个2x2方格中优秀的个数mean &lt;- mean(area)#平均值var&lt;-var(area)#方差VMR&lt;-var/mean# 0.7174515可大致判断为好学生在教室是随机分布的</code></pre><h4 id="5-核密度估计-相比样方法更合理一点"><a href="#5-核密度估计-相比样方法更合理一点" class="headerlink" title="5.核密度估计(相比样方法更合理一点)"></a>5.核密度估计(相比样方法更合理一点)</h4><h5 id="5-1处理数据，选取带宽，但由于带宽太大不好算，所以在不导入第三方包的情况下选择1为带宽。"><a href="#5-1处理数据，选取带宽，但由于带宽太大不好算，所以在不导入第三方包的情况下选择1为带宽。" class="headerlink" title="5.1处理数据，选取带宽，但由于带宽太大不好算，所以在不导入第三方包的情况下选择1为带宽。"></a>5.1处理数据，选取带宽，但由于带宽太大不好算，所以在不导入第三方包的情况下选择1为带宽。</h5><pre><code>#核密度方法DK&lt;-1#定义带宽cd&lt;-merge(1:10,1:8)cd&lt;-cbind(cd,v=0)#添加一行存储该座位上是不是好学生，初始为0，不是好学生seat5&lt;-cbind(x=seat[(1:num),1]%%xnum+1,y=seat[(1:num),1]%/%xnum+1)seat6&lt;-cbind(seat5,fdata[2])#生成数据框for(i in 1:num){      #print(seat6[i,])      for(p in 1:80){         if(seat6[i,][,1]==cd[p,][,1]&amp;seat6[i,][,2]==cd[p,][,2]&amp;seat6[i,][,3]&gt;=bestgpa)         {            cd[p,][,3]=1         }      }}#进行核密度算法，获取指定带宽周围有多少个好学生for(p in 1:80){      x=cd[p,][,1]      y=cd[p,][,2]      v=cd[p,][,3]      for(i in 1:80){         if(x==cd[i,][,1]&amp;y+1==cd[i,][,2]){            v=v+cd[i,][,3]         }         if(x-1==cd[i,][,1]&amp;y==cd[i,][,2]){            v=v+cd[i,][,3]         }         if(x+1==cd[i,][,1]&amp;y-1==cd[i,][,2]){            v=v+cd[i,][,3]         }         if(x+1==cd[i,][,1]&amp;y==cd[i,][,2]){            v=v+cd[i,][,3]         }         if(x==cd[i,][,1]&amp;y-1==cd[i,][,2]){            v=v+cd[i,][,3]         }         if(x-1==cd[i,][,1]&amp;y+1==cd[i,][,2]){            v=v+cd[i,][,3]         }         if(x+1==cd[i,][,1]&amp;y+1==cd[i,][,2]){            v=v+cd[i,][,3]         }         if(x-1==cd[i,][,1]&amp;y-1==cd[i,][,2]){            v=v+cd[i,][,3]         }         cd[p,][,4]=v      }   }#将cd转化为空间点或网格并展示cds&lt;-coordinates(cd[1:2])sp&lt;-SpatialPointsDataFrame(cds,cd[4])sp1&lt;-as(sp,&quot;SpatialPixelsDataFrame&quot;)#强制转化为SpatialPixelsDataFramerw.colors&lt;-colorRampPalette(c(&quot;grey&quot;,&quot;red&quot;))spplot(sp1,col.regions=rw.colors(17))#绘制核密度图形</code></pre><p>   最终结果如下图所示：<br>   <img src="\img\R与空间分析_img\3-5-1.jpeg" alt="图3-5-1 核聚类展示"></p>]]></content>
      
      
      <categories>
          
          <category> R语言空间信息挖掘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R语言 </tag>
            
            <tag> 数据挖掘 </tag>
            
            <tag> gis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R语言空间信息挖掘（二）</title>
      <link href="/2019/03/16/R%E8%AF%AD%E8%A8%80%E7%A9%BA%E9%97%B4%E4%BF%A1%E6%81%AF%E6%8C%96%E6%8E%98%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2019/03/16/R%E8%AF%AD%E8%A8%80%E7%A9%BA%E9%97%B4%E4%BF%A1%E6%81%AF%E6%8C%96%E6%8E%98%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一-空间数据可视化"><a href="#一-空间数据可视化" class="headerlink" title="一.空间数据可视化"></a>一.空间数据可视化</h2><pre><code>R语言有两个绘图系统：传统绘图系统和lattice程序包提供的Trellis绘图系统，目前R语言默认安装了这个程序包。SP包提供了增强传统R语言绘图系统的plot方法，以及一个使用Trellis系统(特别是lattice包中的xyplot或levelplot)并能够用于条件绘图的名为spplot的新通用方法。</code></pre><h3 id="1-传统绘图系统"><a href="#1-传统绘图系统" class="headerlink" title="1.传统绘图系统"></a>1.传统绘图系统</h3><h4 id="1-1绘制点、线、多边形、和网格"><a href="#1-1绘制点、线、多边形、和网格" class="headerlink" title="1.1绘制点、线、多边形、和网格"></a>1.1绘制点、线、多边形、和网格</h4><a id="more"></a><pre><code>在接下来的例子中，从sp程序包中通过data函数获得data.frame对象，并从data.frame对象创建点、线、多边形以及网格对象并绘制图形。&gt; library(sp)&gt; data(&quot;meuse&quot;)&gt; coordinates(meuse)&lt;-c(&quot;x&quot;,&quot;y&quot;)&gt; plot(meuse)结果如下图所示：</code></pre><p><img src="\img\R与空间分析_img\2-1-1.jpg" alt="图1.1.1 点"></p><pre><code>&gt; library(sp)&gt; data(&quot;meuse&quot;)&gt; coordinates(meuse)&lt;-c(&quot;x&quot;,&quot;y&quot;)&gt; cc&lt;- coordinates(meuse)&gt; line&lt;-Line(cc)&gt; lines&lt;-Lines(line,ID=&quot;a&quot;)&gt; m.s1&lt;-SpatialLines(list(lines))&gt; plot(m.s1)&gt; title(&quot;Lines&quot;)结果如下图所示：</code></pre><p><img src="\img\R与空间分析_img\2-1-2.jpg" alt="图1.1.2 线"></p><pre><code>&gt; library(sp)&gt; data(&quot;meuse&quot;)&gt; data(&quot;meuse.riv&quot;)&gt; meuse.lst&lt;-list(Polygons(list(Polygon(meuse.riv)),&quot;meuse.riv&quot;))&gt; meuse.sr&lt;-SpatialPolygons(meuse.lst)&gt; plot(meuse.sr,col=&quot;red&quot;)&gt; title(&quot;polygons&quot;)结果如下图所示：</code></pre><p><img src="\img\R与空间分析_img\2-1-3.jpg" alt="图1.1.3 多边形"></p><pre><code>&gt; library(sp)&gt; data(&quot;meuse.grid&quot;)&gt; coordinates(meuse.grid)&lt;-c(&quot;x&quot;,&quot;y&quot;)&gt; meuse.grid&lt;-as(meuse.grid,&quot;SpatialPixels&quot;)&gt;image(meuse.grid,col=&quot;green&quot;)&gt;title(&quot;grid&quot;)结果如下图所示：</code></pre><p><img src="\img\R与空间分析_img\2-1-4.jpg" alt="图1.1.4 网格"></p><h4 id="1-2-布局元素"><a href="#1-2-布局元素" class="headerlink" title="1.2 布局元素"></a>1.2 布局元素</h4><pre><code>可以使用axes=TRUE为图添加坐标轴，也还可以添加比例尺和指北针......</code></pre><h4 id="1-3-绘图属性和地图图例"><a href="#1-3-绘图属性和地图图例" class="headerlink" title="1.3 绘图属性和地图图例"></a>1.3 绘图属性和地图图例</h4><table><thead><tr><th>类名</th><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>SpatialLinesDataFrame</td><td>col</td><td>颜色</td></tr><tr><td></td><td>lwd</td><td>线宽</td></tr><tr><td></td><td>lty</td><td>线类型</td></tr><tr><td>SpatialPolygonsDataFrame</td><td>border</td><td>边框颜色</td></tr><tr><td></td><td>density</td><td>散列密度</td></tr><tr><td></td><td>angle</td><td>散列角度</td></tr><tr><td></td><td>lty</td><td>线类型</td></tr><tr><td></td><td>pgb</td><td>孔颜色</td></tr><tr><td>SpatialPointsDataFrame</td><td>pch</td><td>符号</td></tr><tr><td></td><td>col</td><td>颜色</td></tr><tr><td></td><td>bg</td><td>填充颜色</td></tr><tr><td></td><td>cex</td><td>符号尺寸</td></tr><tr><td>SpatialPixelsDataFrame和SpatialGridDataFrame</td><td>zlim</td><td>符号属性值</td></tr><tr><td></td><td>col</td><td>颜色</td></tr><tr><td></td><td>breaks</td><td>断点</td></tr></tbody></table><h4 id="1-4-根据实际例子学习"><a href="#1-4-根据实际例子学习" class="headerlink" title="1.4.根据实际例子学习"></a>1.4.根据实际例子学习</h4><h5 id="1-4-1可视化SpatialPointsDataFrame"><a href="#1-4-1可视化SpatialPointsDataFrame" class="headerlink" title="1.4.1可视化SpatialPointsDataFrame"></a>1.4.1可视化SpatialPointsDataFrame</h5><pre><code>&gt; library(sp)&gt; cd&lt;-coordinates(merge(1:10,1:10))&gt; da&lt;-data.frame(da=1:100)&gt; sp1&lt;-SpatialPointsDataFrame(cd,da)&gt; plot(sp1,pch=15,col=cols)</code></pre><p>注意将向量转化为矩阵的rbind(),cbind(),merge()方法的区别。这里运用的就是普通的plot方法。<br><img src="\img\R与空间分析_img\2-2-1.jpg" alt="图1.4.1 空间点可视化"></p><h5 id="1-4-2可视化SpatialGridDataFrame"><a href="#1-4-2可视化SpatialGridDataFrame" class="headerlink" title="1.4.2可视化SpatialGridDataFrame"></a>1.4.2可视化SpatialGridDataFrame</h5><pre><code>&gt;library(sp)&gt;gd&lt;-GridTopology(cellcentre.offset = c(1,1), cellsize=c(1,1), cells.dim = c(8,9))&gt;SpG&lt;-SpatialGrid(gd)&gt;da&lt;-data.frame(da=1:72)&gt;SpGF&lt;-SpatialGridDataFrame(SpG,da)&gt;plot(SpGF,zlim=c(0,100))</code></pre><p>注意这里生成SpatialGrid只需要了grid，而不需要SpatialPoints,通过getClass(SpG)可以看见SpatialPoints。<br><img src="\img\R与空间分析_img\2-2-2.jpg" alt="图1.4.2 空间网格可视化"></p><h3 id="2-使用Spplot的Trellis-Lattice绘制"><a href="#2-使用Spplot的Trellis-Lattice绘制" class="headerlink" title="2.使用Spplot的Trellis/Lattice绘制"></a>2.使用Spplot的Trellis/Lattice绘制</h3><pre><code>Spplot与plot的优势是对于带有空间数据的属性，对于条件绘图的支持度很好。缺点是对于注释和图例等处理比较麻烦</code></pre><h4 id="2-1根据实际例子学习"><a href="#2-1根据实际例子学习" class="headerlink" title="2.1根据实际例子学习"></a>2.1根据实际例子学习</h4><h5 id="2-1-1-将1-4中的例子分别用spplot代替plot-得到下面的结果："><a href="#2-1-1-将1-4中的例子分别用spplot代替plot-得到下面的结果：" class="headerlink" title="2.1.1 将1.4中的例子分别用spplot代替plot,得到下面的结果："></a>2.1.1 将1.4中的例子分别用spplot代替plot,得到下面的结果：</h5><p><img src="\img\R与空间分析_img\2-2-2-2.jpg" alt="图2.1.1.1 空间点可视化"></p><p><img src="\img\R与空间分析_img\2-2-2-3.jpg" alt="图2.1.2.2 空间网格可视化"></p><h5 id="2-1-2-条件绘图"><a href="#2-1-2-条件绘图" class="headerlink" title="2.1.2 条件绘图"></a>2.1.2 条件绘图</h5><pre><code>将网格可视化的&lt; da&lt;-data.frame(da=1:72)改为&lt; da&lt;-data.frame(da=1:72,da1=72:1)即增加一行属性数据，使用spplot绘图得到如下结果</code></pre><p><img src="\img\R与空间分析_img\2-2-2-4.jpg" alt="图2.1.2 spplot空间网格可视化"><br>    可以与plot创造的图像有明显优势。</p>]]></content>
      
      
      <categories>
          
          <category> R语言空间信息挖掘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R语言 </tag>
            
            <tag> 数据挖掘 </tag>
            
            <tag> gis </tag>
            
            <tag> 可视化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R语言空间信息挖掘（一）</title>
      <link href="/2019/03/15/R%E8%AF%AD%E8%A8%80%E7%A9%BA%E9%97%B4%E4%BF%A1%E6%81%AF%E6%8C%96%E6%8E%98%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2019/03/15/R%E8%AF%AD%E8%A8%80%E7%A9%BA%E9%97%B4%E4%BF%A1%E6%81%AF%E6%8C%96%E6%8E%98%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一-R语言空间信息挖掘简介"><a href="#一-R语言空间信息挖掘简介" class="headerlink" title="一.R语言空间信息挖掘简介"></a>一.R语言空间信息挖掘简介</h2><pre><code>R系统是一款基于统计计算和绘图的免费软件。R系统提供了许多标准的和创新的统计分析方法。在过去的10年，R语言拥有越来越多用于处理和分析空间数据的包。其中一组R开发者实现了R包sp,它新增的用于空间数据的类和方法扩展了R的功能。sp包提供了点、线、多边形和网格的类和方法，采用单组空间数据类有许多重要的优势。本实验就是基于sp包进行。</code></pre><a id="more"></a><h2 id="二-空间数据的类型"><a href="#二-空间数据的类型" class="headerlink" title="二.空间数据的类型"></a>二.空间数据的类型</h2><pre><code>空间数据有空间坐标值以及这些坐标的参照系。具体在sp包中如下：</code></pre><blockquote><ul><li>点：一个单点位置，比如全球定位系统读取的位置或地理编码；</li><li>线：有序点的集合，由直线段相连；</li><li>多边行：一个区域，由一条或以上的封闭线组成，可能含孔；</li><li>网格：点或矩形单元的集合，由<strong>规则的栅格</strong>构成。</li></ul></blockquote><pre><code>前三个是矢量数据，表示尽量精准的实体，而最后一个数据模型是栅格数据模型，表示使用规则单元铺盖的连续表面。所有的空间数据包含位置信息，可以说明位置在哪里。</code></pre><h2 id="三-R的空间数据类"><a href="#三-R的空间数据类" class="headerlink" title="三.R的空间数据类"></a>三.R的空间数据类</h2><h3 id="1-Spatial对象"><a href="#1-Spatial对象" class="headerlink" title="1.Spatial对象"></a>1.Spatial对象</h3><pre><code>    Spatial类是基类，只有两个槽(槽被指定为类中所包含成员的表示方法)，第一个是约束盒，它是一个数值坐标矩阵，拥有列名为c(&apos;min&apos;,&apos;max&apos;)的数值坐标，至少有两行，即x-轴，y-轴。第二个是定义类坐标参考的CRS类对象，默认值为NA(缺失值)。可以使用getClass方法来获取类的完整定义，包括槽的名字及其内容和类型：&gt;library(sp)&gt;getClass(&quot;Spatial&quot;)Class &quot;Spatial&quot; [package &quot;sp&quot;]Slots:Name: bbox    proj4stringClass:matrix  CRS这里的Name和Class应该是上下对应的关系。所以要创建一个Spatial类的方法：&gt; s&lt;-Spatial(bbox=m,proj4string=crs)这里的m和crs就是对应的matrix(矩阵)和CRS类(创建crs类同理可根据getClass(&quot;CRS&quot;)看参数创建)。bbox为边界。</code></pre><h3 id="2-SpatialPoints类"><a href="#2-SpatialPoints类" class="headerlink" title="2.SpatialPoints类"></a>2.SpatialPoints类</h3><pre><code>SpatialPoints类是Spatial类的第一个子类。通过使用getClass(&quot;SpatialPoints&quot;)可以看出SpatialPoints类比Spatial多了一个coords槽(坐标)，扩展后可以插入坐标矩阵。</code></pre><h4 id="2-1-方法"><a href="#2-1-方法" class="headerlink" title="2.1 方法"></a>2.1 方法</h4><pre><code>方法用来访问Spatial对象的值。</code></pre><blockquote><ul><li>bbox(<em>SpatialPoints</em>)获取空间点的边界</li><li>proj4string(<em>SpatialPoints</em>)获取或设置投影</li><li>coordinates(<em>SpatialPoints</em>)获取坐标矩阵，可以进行索引筛选。</li></ul></blockquote><h4 id="2-2-空间点数据的数据框"><a href="#2-2-空间点数据的数据框" class="headerlink" title="2.2 空间点数据的数据框"></a>2.2 空间点数据的数据框</h4><pre><code>SpatialPointDataFrame的构成如下图所示（2-2）。</code></pre><p><img src="\img\R与空间分析_img\2-2.jpg" alt="图2-2"></p><pre><code>这个类扩展了SpatialPoints，继承了Spatial类对象所包含的信息。在一个data.frame对象中数据框信息保存在data槽中。</code></pre><h3 id="3-SpatialLines和SpatialPolygons"><a href="#3-SpatialLines和SpatialPolygons" class="headerlink" title="3.SpatialLines和SpatialPolygons"></a>3.SpatialLines和SpatialPolygons</h3><pre><code>关于这两个类与SpatialPoints类相似，其组成如图3所示</code></pre><p><img src="\img\R与空间分析_img\3.jpg" alt="图3"></p>]]></content>
      
      
      <categories>
          
          <category> R语言空间信息挖掘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R语言 </tag>
            
            <tag> 数据挖掘 </tag>
            
            <tag> gis </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
