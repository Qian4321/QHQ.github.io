<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2019/10/21/%E7%90%86%E6%B8%85redux%E5%92%8Creact-redux%E7%9A%84%E6%80%9D%E8%B7%AF/"/>
      <url>/2019/10/21/%E7%90%86%E6%B8%85redux%E5%92%8Creact-redux%E7%9A%84%E6%80%9D%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<hr><p>title: 理清redux和react-redux的思路<br>date: 2019-10-21 22:28:45<br>tags: #定义标签  </p><ul><li>redux  </li><li>react-redux<br>categories: react #定义分类  </li></ul><hr><h3 id="1-流程"><a href="#1-流程" class="headerlink" title="1.流程"></a>1.流程</h3><p><span style="color:#311B92"><br>&emsp;&emsp;首先redux是用来生成store的，react-redux是将store和context结合起来的生成connect()。在生成store的时候，需要传入reducer函数,这个函数带有两个参数，一个是state另一个是action。这样做就可以在redux的createStore中生成三个函数，分别是获取state的函数getState(),改变state的函数dispatch({}),重新渲染页面的subscribe()。<br></span>  </p><h4 id="1-1-createStore"><a href="#1-1-createStore" class="headerlink" title="1.1 createStore()"></a>1.1 createStore()</h4><p><span style="color:#311B92"><br>大概实现：<br></span>  </p><a id="more"></a><pre style="background-color:#E1F5FE;color:#01579B">          function createStore (reducer) {              let state = null              const listeners = []              const subscribe = (listener) => listeners.push(listener)              const getState = () => state              const dispatch = (action) => {                  state = reducer(state, action)                  listeners.forEach((listener) => listener())              }              dispatch({}) // 初始化 state              return { getState, dispatch, subscribe }          }  </pre>  <p><span style="color:#311B92"><br>&emsp;&emsp;传入的reducer有state参数和action参数，state就是数据，action就好像是菜单，定义了许多不同的type操作state，大概格式如下：<br></span>  </p><pre style="background-color:#E1F5FE;color:#01579B">          function themeReducer (state, action) {              if (!state) return {                  themeName: 'Red Theme',                  themeColor: 'red'              }              switch (action.type) {                  case 'UPATE_THEME_NAME':                  return { ...state, themeName: action.themeName }                  case 'UPATE_THEME_COLOR':                  return { ...state, themeColor: action.themeColor }                  default:                  return state              }          }          const store = createStore(themeReducer);//生成store  </pre>  <h5 id="1-1-1-getState"><a href="#1-1-1-getState" class="headerlink" title="1.1.1 getState"></a>1.1.1 getState</h5><p><span style="color:#311B92"><br>&emsp;&emsp;获取state<br></span>  </p><h5 id="1-1-2-dispatch"><a href="#1-1-2-dispatch" class="headerlink" title="1.1.2 dispatch"></a>1.1.2 dispatch</h5><p><span style="color:#311B92"><br>&emsp;&emsp;dispatch()传入一个对象，类似于点单，对象包含type属性和其他参数。<br></span>  </p><h5 id="1-1-3-subscribe"><a href="#1-1-3-subscribe" class="headerlink" title="1.1.3 subscribe"></a>1.1.3 subscribe</h5><p><span style="color:#311B92"><br>&emsp;&emsp;subscribe()参入函数，使用观察者模式将函数添加到listeners数组中，在dispatch中全部遍历listeners[],调用添加到其中的函数，一般是更新函数。类似于：<br></span>  </p><pre style="background-color:#E1F5FE;color:#01579B">          function renderApp (appState) {              console.log('render app...')          }          store.subscribe(() => renderApp(store.getState())) // 监听数据变化  </pre>  <h4 id="1-2-Provider组件"><a href="#1-2-Provider组件" class="headerlink" title="1.2 Provider组件"></a>1.2 Provider组件</h4><p><span style="color:#311B92"><br>&emsp;&emsp;Provide是包裹根组件的组件，主要是将context的操作从根组件中排除。同时将生成store传入进去。大概的实现与使用如下:  </span></p><p>  </p><pre style="background-color:#E1F5FE;color:#01579B">          export class Provider extends Component {              static propTypes = {                  store: PropTypes.object,                  children: PropTypes.any              }              static childContextTypes = {                  store: PropTypes.object              }              getChildContext () {                  return {                  store: this.props.store                  }              }              render () {                  return (                  <div>{this.props.children}</div>                  )              }          }          <!-- 使用 -->        // 头部引入 Provider        import { Provider } from './react-redux'        ...        // 删除 Index 里面所有关于 context 的代码        class Index extends Component {        render () {            return (            <div>                <header>                <content>            </content></header></div>            )        }        }        // 把 Provider 作为组件树的根节点        ReactDOM.render(        <provider store="{store}">            <index>        </index></provider>,        document.getElementById('root')        )</pre>  <h4 id="1-2-connect"><a href="#1-2-connect" class="headerlink" title="1.2 connect()"></a>1.2 connect()</h4><p><span style="color:#311B92"><br>&emsp;&emsp;connect这是将普通组件与context.store联系起来的东西。在传参数可以看成是三个参数:第一个是mapStateToProps，从state中筛选需要的数据。第二个是mapDispatchToProps，筛选要使用的Patch。<br></span></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>10/21/2019</title>
      <link href="/2019/10/21/10-21-2019/"/>
      <url>/2019/10/21/10-21-2019/</url>
      
        <content type="html"><![CDATA[<h4 id="10-18-2019"><a href="#10-18-2019" class="headerlink" title="10/18/2019"></a>10/18/2019</h4><p><span style="color:#311B92"><br>&emsp;&emsp;昨天实在太无聊了，实在写不出来……<br><a id="more"></a><br>&emsp;&emsp;明天就要上班了，今天去办理了一些报道需要的文件。这里不得不吐槽一下招商银行，营业厅也太少了吧，办个业务要从双流区跑到武侯区，贼烦。再说说入职的心情吧，我现在贼慌。我也知道万事开头难，但紧张是在所难免的。想一想这么些年自己一个人学技术的时候开头都很难受，现在回想起来其实都不值一提。我也很好奇一年以后我来看这条blog的时候那时候的我是啥感受，估计也是不值一提吧。不说了，写技术blog去了。<br></span></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>10/19/2019</title>
      <link href="/2019/10/19/10-19-2019/"/>
      <url>/2019/10/19/10-19-2019/</url>
      
        <content type="html"><![CDATA[<h4 id="10-18-2019"><a href="#10-18-2019" class="headerlink" title="10/18/2019"></a>10/18/2019</h4><p><span style="color:#311B92"><br>&emsp;&emsp;今天是及其平淡的一天，唯一刺激的就是rng vs skt的比赛了。我和朋友打赌rng赢比赛，他赌skt，然后我果然输掉了。赌注高达10元人民币，难受。还有一件事就是我想起我要考6级，但我发现6级报名的时间已经过了，难受。晚上厕所水管爆了，修理工下班第二天才修，被迫断水，难受。<br><a id="more"></a><br>&emsp;&emsp;突然觉得以前学一些东西的时候感觉没啥用，但后来才觉得多学一点总是好的，因为你也不知道这些知识会在未来以哪种形式出现。说明复出总有回报，只是时间长短问题。还有，以后的随笔不想搞图片了，好难加载啊，没啥意义。<br></span></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>10/18/2019</title>
      <link href="/2019/10/18/10-18-2019/"/>
      <url>/2019/10/18/10-18-2019/</url>
      
        <content type="html"><![CDATA[<h4 id="10-18-2019"><a href="#10-18-2019" class="headerlink" title="10/18/2019"></a>10/18/2019</h4><p><span style="color:#311B92"><br>&emsp;&emsp;今天又参加了招聘会，这次是校友招聘会，招聘企业还蛮多的，但适合的却很少。尤其是前端的岗位，我感触最深。凡事只要招前端的公司，在排队递简历的同学基本都是搞前端的。这种入门简单深入难的岗位真的搞得人很难受。大量的人卡在入门级，无法得到足够的锻炼进阶就导致了严重的两极分化。之所以感受这么深，是因为我就是受害者啊！但我享受前端技术不断更新带给我的新鲜感与刺激感。<br><a id="more"></a></span></p><p>&emsp;&emsp;但今天的招聘会没投简历，因为确实没有时间去面试了，我不喜欢复习那些面试的知识点，我跟喜欢学习新的技术，并应用起来。这才有乐趣嘛。所以这一趟主要还是陪朋友去参加吧。在招聘会现场也碰见了许多以前一起跑招聘会的同学，还是挺有感触的。反正努力吧，周末要加班学习了，毕竟要上班了。<br></p><p><img src="\img\随笔\2019\10\18.jpg" alt="图1.1.1 点"></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>10/17/2019</title>
      <link href="/2019/10/17/10-17-2019/"/>
      <url>/2019/10/17/10-17-2019/</url>
      
        <content type="html"><![CDATA[<h4 id="10-17-2019"><a href="#10-17-2019" class="headerlink" title="10/17/2019"></a>10/17/2019</h4><p><span style="color:#311B92"><br>&emsp;&emsp;今天去拍要贴在毕业证上的证件照，一大早就起床了，算是提前感受了下上班早起的感觉。果不其然困了一上午，还是需要调一下生物钟了。到了一教学楼排队等待，又看见了许多的同学。进入大四后很少有机会能把大家凑得这么齐，确实也有一点离别的味道了。不过还是聊得很开心。拍照时最难受的就是眨眼睛了，他越是让我忍住不眨，我越是想眨……不过最后还是顺利完成了。后面出教室的时候可以预览自己的照片，我也确实好久没有看见过这么原生的照片了，贼丑。果然他那里就提供p图的功能，这商业链够强的。不过我还是决定放弃，是啥样就是啥样，也没必要太过包装。<br><br><a id="more"></a><br>&emsp;&emsp;今天也开始学习react了，感觉不像网上说的那样学习路线很陡峭，可能是我对vue比较熟悉吧。也理解JD要求三大框架会一种就行了，原来是转其他的框架其实蛮简单的。也吧react和vue进行了简单的比较，其实是比较相似的，但不同之处也比较明显。明天去看看学校的大型招聘会，然后把react的基础看完，周末看看源码，学习一下原理。<br></span></p><div style="text-align:center"><br>  <image src="\img\随笔\2019\10\17.jpg" style="width:75vw;height:85vw"><br></image></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>yarn的小总结</title>
      <link href="/2019/10/16/yarn%E7%9A%84%E5%B0%8F%E6%80%BB%E7%BB%93/"/>
      <url>/2019/10/16/yarn%E7%9A%84%E5%B0%8F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h4 id="1-关于yarn"><a href="#1-关于yarn" class="headerlink" title="1.关于yarn"></a>1.关于yarn</h4><p><span style="color:#311B92"><br>&emsp;&emsp;npm和yarn的关系类似于Linux的rpm和yum,导致我在很长一段时间里将yarn记成了yum,脑残。yarn和yum都是帮助使用者处理包的依赖问题，yum的着重点在依赖包的下载，而yarn主要是处理依赖包的版本问题。yarn相对于npm的优势如下:<br><a id="more"></a></span></p><p><ul style="color:#8E24AA"><br>  <li>速度快 ： 主要来自以下两个方面：<br>    <ul><br>        <li>并行安装：并行执行所有任务，提高了性能。<br>        </li><br>        <li>离线模式：如果之前已经安装过一个软件包，再次安装时直接从缓存中获取。<br>        </li><br>    <ul><br>  </ul></ul></li><br>  <li>安装版本统一：每一次拉取同一个项目依赖时，使用的都是一样的模块版本。<br>  </li><br>  <li>更简洁的输出： Yarn结合了 emoji直观且直接地打印出必要的信息，也提供了一些命令供开发者查询额外的安装信息。<br>  </li><br>  <li>多注册来源处理：所有的依赖包，不管他被不同的库间接关联引用多少次，安装这个包时，只会从一个注册来源去装，要么是 npm 要么是 bower, 防止出现混乱不一致。<br>  </li><br>  <li>更好的语义化： yarn改变了一些npm命令的名称，比如 yarn add/remove，感觉上比 npm 原本的 install/uninstall 要更清晰。<br>  </li><br></ul><br><span style="color:#311B92">总之，yarn很diao，快用ta。<br></span></p><h4 id="2-yarn与npm的命令对比（来自http-www-fly63-com-article-detial-554）"><a href="#2-yarn与npm的命令对比（来自http-www-fly63-com-article-detial-554）" class="headerlink" title="2.yarn与npm的命令对比（来自http://www.fly63.com/article/detial/554）"></a>2.yarn与npm的命令对比（来自<a href="http://www.fly63.com/article/detial/554）" target="_blank" rel="noopener">http://www.fly63.com/article/detial/554）</a></h4><table width="100%"><thead style="background-color:#D1C4E9"><tr><th>npm</th><th>yarn</th></tr></thead><tbody style="background-color:#E8EAF6"><tr><td>npm install</td><td>yarn install</td></tr><tr><td>(N/A)</td><td>yarn install –flat</td></tr><tr><td>(N/A)</td><td>yarn install –har</td></tr><tr><td>(N/A)</td><td>yarn install –no-lockfile</td></tr><tr><td>(N/A)</td><td>yarn install –pure-lockfile</td></tr><tr><td>npm install [package]</td><td>(N/A)</td></tr><tr><td>npm install –save [package]</td><td>yarn add [package]</td></tr><tr><td>npm install –save-dev [package]</td><td>yarn add [package] [–dev/-D]</td></tr><tr><td>(N/A)</td><td>yarn add [package] [–peer/-P]</td></tr><tr><td>npm install –save-optional [package]</td><td>yarn add [package] [–optional/-O]</td></tr><tr><td>npm install –save-exact [package]</td><td>yarn add [package] [–exact/-E]</td></tr><tr><td>(N/A)</td><td>yarn add [package] [–tilde/-T]</td></tr><tr><td>npm install –global [package]</td><td>yarn global add [package]</td></tr><tr><td>npm rebuild</td><td>yarn install –force</td></tr><tr><td>npm uninstall [package]</td><td>(N/A)</td></tr><tr><td>npm uninstall –save [package]</td><td>yarn remove [package]</td></tr><tr><td>npm uninstall –save-dev [package]</td><td>yarn remove [package]</td></tr><tr><td>npm uninstall –save-optional [package]</td><td>yarn remove [package]</td></tr><tr><td>npm cache clean</td><td>yarn cache clean</td></tr><tr><td>rm -rf node_modules &amp;&amp; npm install</td><td>yarn upgrade</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 小技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> yarn </tag>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10/16/2019</title>
      <link href="/2019/10/16/10-16-2019/"/>
      <url>/2019/10/16/10-16-2019/</url>
      
        <content type="html"><![CDATA[<h4 id="10-16-2019"><a href="#10-16-2019" class="headerlink" title="10/16/2019"></a>10/16/2019</h4><p><span style="color:#311B92"><br>&emsp;&emsp;今天开始学react了，我学技术这么多年以来最坚定的一句话就是“万事开头难”，但这个开头着实有点搞。被以前全局安装的webpack搞心态了，所以说全局安装还是少用吧。不过也正因为这样额外系统学了下yarn,以前一直以为只有在linux中才能使用yarn……我太菜了。明天比较一下react和vue的区别再好好的进一步学习。<br><br>&emsp;&emsp;中午和一个在内蒙的朋友聊了蛮久，知道好多以前的同学都签了三方，才意识到比我努力的人多了去了。所以要更加努力。<br><br>&emsp;&emsp;晚饭吃完告诉了我妈我下周（10月22日）要上班的事，果不其然第一件事就是问我的实习工资。我如实的告诉了她之后瞬间就被嫌弃<br>了，但也在意料之中。她一直对一个本科生赚的钱还没她多就感到十分不解。吐槽一番后说我的生日快到了，然后强调了她的生日是在我的生日的下一个月。然后似有若无的透露出想要一个华为手机。笑死我了。我便说我发工资了给她买一个，她说我不要你那点渣渣钱，你自己留着过年吧。然后又给我转了点生活费。其实我是满难过的，这么大了还在要钱，不过以后每个月多少都能存一点钱了。慢慢来吧，我有预感我会是个富翁。<br></span><br><a id="more"></a></p><div style="text-align:center"><br>  <image src="\img\随笔\2019\10\16.jpg" style="width:75vw;height:85vw"><br></image></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>10/15/2019</title>
      <link href="/2019/10/15/10-15-2019/"/>
      <url>/2019/10/15/10-15-2019/</url>
      
        <content type="html"><![CDATA[<h4 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h4><p><span style="color:#311B92"><br>&emsp;&emsp;在几次校招的铩羽而归时，逐渐明白了自己身上存在的问题——沟通与说话的逻辑。这个是几个面试官明确告诉我的缺点，也是秋招收获最大的东西了。在秋招如此严峻的情况下，才发现学历与经验和在校经历其实是蛮重要的。就好像每年评奖学金，不单单只看成绩，德育分的占比也是很重要的。然后也咨询了面试官，说写博客可以锻炼自己的表达逻辑能力，所以也趁着这个时机把自己遗忘了三个多月的博客运营起来。也决定以后每天必须总结当天的事情与感受。<br></span><br><a id="more"></a></p><h4 id="10-15-2019"><a href="#10-15-2019" class="headerlink" title="10/15/2019"></a>10/15/2019</h4><p><span style="color:#311B92"><br>&emsp;&emsp;今天决定放弃秋招，开启实习之旅。其实本来还打算继续开始征战秋招的，但是真的很累。而且以目前的我的实力来说，确实也不配被秋招到好公司。今天在微信上和当时面试我的面试官聊天，也更加坚定我去他那里实习的想法。因为他是为数不多的肯定我的面试官之一，其实还是蛮感谢他的。他在微信上让我学一些技术，还是蛮让我意外的，意外的是他的信任。明天开始就学新技术了。终于不用天天看面试攻略了，快吐了。<br>希望再小，也值得尝试。</span></p><p></p><div style="text-align:center"><br>  <image src="\img\随笔\2019\10\15.jpg" style="width:75vw;height:85vw"><br></image></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我的webpack学习（一）</title>
      <link href="/2019/10/14/%E6%88%91%E7%9A%84webpack%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2019/10/14/%E6%88%91%E7%9A%84webpack%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="一-webpack的常用配置"><a href="#一-webpack的常用配置" class="headerlink" title="一.webpack的常用配置"></a>一.webpack的常用配置</h3><h4 id="1-entry和output"><a href="#1-entry和output" class="headerlink" title="1.entry和output"></a>1.entry和output</h4><pre style="background-color:#E1F5FE;color:#01579B">    module.exports={      entry:'./src/index.js',      output:{        path:path.resolve(__dirname,'dist'),        filename:'bundle[hash:6].js',        publicPath:'http://www.baidu.com'      }    }</pre><p><span style="color:#311B92">&emsp;&emsp;其中entry是需要打包的文件路径，可以提供多个路径，但提供多个入口路径时，在output的输出打包文件时需要使用占位符来确保每个文件不一样。<br></span></p><a id="more"></a><h4 id="2-mode"><a href="#2-mode" class="headerlink" title="2.mode"></a>2.mode</h4><p><span style="color:#311B92">&emsp;&emsp;mode主要是来表明当前软件处于开发环境还是生产环境。在开发环境中可以使用devtool来进行代码的debug，可以使用webpack-dev-server开启本地便捷服务器和热替换模块。在生产环境中就将mode更改为production,在生产环境中会默认开启一些插件之类得东西，比如tree-shaking需要使用的UglifyJsPlugin插件和optimization.usedExports，同时设置配置optimization选项，设置usedExports和sideEffects为true。大概配置如下：</span></p><pre style="background-color:#E1F5FE;color:#01579B">    // webpack.config.js    const UglifyJsPlugin = require('uglifyjs-webpack-plugin');    const HtmlWebpackPlugin = require('html-webpack-plugin');    module.exports = {        mode: 'none',        optimization: {            minimize: true,            minimizer: [                new UglifyJsPlugin()            ],            usedExports: true,            sideEffects: true        },        plugins: [            new HtmlWebpackPlugin()        ]    }</pre><p></p><h4 id="3-modules"><a href="#3-modules" class="headerlink" title="3.modules"></a>3.modules</h4><p><span style="color:#311B92">&emsp;&emsp;modules主要是提供各种loader来对各种非Js模块来进行解析，常用的loader包括:<br>  <ol style="color:#8E24AA"><br>    <li>babel-loader:主要是用来将es6等代码转换为浏览器可识别的代码。<br>    </li><br>    <li>css-loader,style-loader:来打包css文件<br>    </li><br>    <li>file-loader:用来打包图片啊，啥的。<br>    </li><br>    <li>sass-loader,scss-loader:打包css预处理器<br>    </li><br>  </ol><br></span></p><h4 id="4-plugins"><a href="#4-plugins" class="headerlink" title="4.plugins"></a>4.plugins</h4><p><span style="color:#311B92">&emsp;&emsp;插件可以看做loader的加强版，用法大概是：</span></p><pre style="background-color:#E1F5FE;color:#01579B">plugins: [    new webpack.optimize.UglifyJsPlugin(),    new HtmlWebpackPlugin({template: './src/index.html'})  ]</pre><p><span style="color:#311B92">&emsp;&emsp;常用的插件大概有：</span></p><p>  <ol style="color:#8E24AA"><br>    <li>CommonsChunkPlugin(SplitChunksPlugin):如果把公共代码抽离成单独文件进行加载能进行优化，可以减少网络传输流量，降低服务器成本<br>    </li><br>    <li>HtmlWebpackPlugin:会将打包后的文件自动引入到html并生成新的html,也可以使用模板文件。<br>    </li><br>  </ol><br></p>]]></content>
      
      
      <categories>
          
          <category> javascript&amp;es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可视化排序（二）</title>
      <link href="/2019/06/12/%E5%8F%AF%E8%A7%86%E5%8C%96%E6%8E%92%E5%BA%8F%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2019/06/12/%E5%8F%AF%E8%A7%86%E5%8C%96%E6%8E%92%E5%BA%8F%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="一-归并排序"><a href="#一-归并排序" class="headerlink" title="一.归并排序"></a>一.归并排序</h3><h4 id="1-归并排序相交于前面的排序都要复杂一些，但是他是可是在实际中被使用的排序方法。归并排序的主要思想是通过递归将数组切分到足够小，比较后交换位置后再进行合并。"><a href="#1-归并排序相交于前面的排序都要复杂一些，但是他是可是在实际中被使用的排序方法。归并排序的主要思想是通过递归将数组切分到足够小，比较后交换位置后再进行合并。" class="headerlink" title="1.归并排序相交于前面的排序都要复杂一些，但是他是可是在实际中被使用的排序方法。归并排序的主要思想是通过递归将数组切分到足够小，比较后交换位置后再进行合并。"></a>1.归并排序相交于前面的排序都要复杂一些，但是他是可是在实际中被使用的排序方法。归并排序的主要思想是通过递归将数组切分到足够小，比较后交换位置后再进行合并。</h4><h4 id="2-部分代码"><a href="#2-部分代码" class="headerlink" title="2.部分代码"></a>2.部分代码</h4><pre><code>const mergesort = function* (array) {  yield mergeSortRec(array);}///递归函数，将数组切割到足够小const mergeSortRec = (array)=&gt;{  let length = array.length;  if (length === 1) {    return array;  }  let mid = Math.floor(length / 2),    left = array.slice(0, mid),    right = array.slice(mid, length);    return merge(mergeSortRec(left), mergeSortRec(right));}//比较左右两边数组，然后合并在一起const merge = (left,right) =&gt; {  let result = [],    il = 0,    ir = 0;  while (il &lt; left.length &amp;&amp; ir &lt; right.length) {    if (left[il] &lt; right[ir]) {      result.push(left[il++]);    } else {      result.push(right[ir++]);    }  }  while (il &lt; left.length) {    result.push(left[il++]);  }  while (ir &lt; right.length) {    result.push(right[ir++]);  }  return result;}export default mergesort;</code></pre><a id="more"></a><h3 id="二-快速排序"><a href="#二-快速排序" class="headerlink" title="二.快速排序"></a>二.快速排序</h3><h4 id="1-快速排序是性能很好的排序算法了，它的主要思想类似于归并排序，但它只是在理论上切割数组，实际数组并没有被切割。最开始找到中间一个点作为主元，然后将比这个主元大的放在右边，比主元小的放在左边，这是左边和右边便可递归看成两个数组重复这个过程，切分到足够小就可以将数组的每一个元素从小到大的排列出来。"><a href="#1-快速排序是性能很好的排序算法了，它的主要思想类似于归并排序，但它只是在理论上切割数组，实际数组并没有被切割。最开始找到中间一个点作为主元，然后将比这个主元大的放在右边，比主元小的放在左边，这是左边和右边便可递归看成两个数组重复这个过程，切分到足够小就可以将数组的每一个元素从小到大的排列出来。" class="headerlink" title="1.快速排序是性能很好的排序算法了，它的主要思想类似于归并排序，但它只是在理论上切割数组，实际数组并没有被切割。最开始找到中间一个点作为主元，然后将比这个主元大的放在右边，比主元小的放在左边，这是左边和右边便可递归看成两个数组重复这个过程，切分到足够小就可以将数组的每一个元素从小到大的排列出来。"></a>1.快速排序是性能很好的排序算法了，它的主要思想类似于归并排序，但它只是在理论上切割数组，实际数组并没有被切割。最开始找到中间一个点作为主元，然后将比这个主元大的放在右边，比主元小的放在左边，这是左边和右边便可递归看成两个数组重复这个过程，切分到足够小就可以将数组的每一个元素从小到大的排列出来。</h4><h4 id="2-动图展示"><a href="#2-动图展示" class="headerlink" title="2.动图展示"></a>2.动图展示</h4><p><img src="\img\js\quick.gif" alt="图1"></p><h4 id="3-部分代码"><a href="#3-部分代码" class="headerlink" title="3.部分代码"></a>3.部分代码</h4><pre><code>const quick = function *(array, left, right) {  let index;  if (array.length &gt; 1) {    index = partition(array, left, right);//返回特定值，将左边划分为小于基准点，右边大于基准点    if (left &lt; index - 1) {      yield array      yield* quick(array, left, index - 1);//递归需使用yeild*    }    if (index &lt; right) {      yield array      yield* quick(array, index, right);    }  }}const partition = (array, left, right)=&gt; {  let pivot = array[Math.floor((right + left) / 2)],//寻找基准点    i = left,    j = right;  while (i &lt;= j) {    while (array[i] &lt; pivot) {//从左边寻找大于基准点的值      i++;    }    while (array[j] &gt; pivot) {      j--;    }    if (i &lt;= j) {      [array[i], array[j]] = [array[j], array[i]];      i++;      j--;    }  }  return i;}export default quick;</code></pre>]]></content>
      
      
      <categories>
          
          <category> javascript&amp;es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 可视化 </tag>
            
            <tag> js </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可视化排序（一）</title>
      <link href="/2019/06/11/%E5%8F%AF%E8%A7%86%E5%8C%96%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2019/06/11/%E5%8F%AF%E8%A7%86%E5%8C%96%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="一-大体介绍"><a href="#一-大体介绍" class="headerlink" title="一.大体介绍"></a>一.大体介绍</h3><h4 id="使用的排序算法包含冒泡排序，选择排序，插入排序，归并排序，快速排序，堆排序，使用echart实现部分排序的可视化排序过程，因为部分排序方法可视化太复杂。"><a href="#使用的排序算法包含冒泡排序，选择排序，插入排序，归并排序，快速排序，堆排序，使用echart实现部分排序的可视化排序过程，因为部分排序方法可视化太复杂。" class="headerlink" title="使用的排序算法包含冒泡排序，选择排序，插入排序，归并排序，快速排序，堆排序，使用echart实现部分排序的可视化排序过程，因为部分排序方法可视化太复杂。"></a>使用的排序算法包含冒泡排序，选择排序，插入排序，归并排序，快速排序，堆排序，使用echart实现部分排序的可视化排序过程，因为部分排序方法可视化太复杂。</h4><h3 id="二-冒泡排序"><a href="#二-冒泡排序" class="headerlink" title="二.冒泡排序"></a>二.冒泡排序</h3><h4 id="1-冒泡排序的主要思想是通过二重for循环，循环比较相邻两项，按照统一的大小排列顺序进行交换位置，性能较差，复杂度为-O-n-2-。"><a href="#1-冒泡排序的主要思想是通过二重for循环，循环比较相邻两项，按照统一的大小排列顺序进行交换位置，性能较差，复杂度为-O-n-2-。" class="headerlink" title="1.冒泡排序的主要思想是通过二重for循环，循环比较相邻两项，按照统一的大小排列顺序进行交换位置，性能较差，复杂度为      O(n^2)。"></a>1.冒泡排序的主要思想是通过二重for循环，循环比较相邻两项，按照统一的大小排列顺序进行交换位置，性能较差，复杂度为      O(n^2)。</h4><h4 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2.代码实现"></a>2.代码实现</h4><h5 id="1）可视化方面选用echart的柱状图。"><a href="#1）可视化方面选用echart的柱状图。" class="headerlink" title="1）可视化方面选用echart的柱状图。"></a>1）可视化方面选用echart的柱状图。</h5><h5 id="2）因为要将每一个排序后的数组状态保存下来，形成一个动态的动画效果，就可以使用Generator和yield配合setInterval来进行实现。"><a href="#2）因为要将每一个排序后的数组状态保存下来，形成一个动态的动画效果，就可以使用Generator和yield配合setInterval来进行实现。" class="headerlink" title="2）因为要将每一个排序后的数组状态保存下来，形成一个动态的动画效果，就可以使用Generator和yield配合setInterval来进行实现。"></a>2）因为要将每一个排序后的数组状态保存下来，形成一个动态的动画效果，就可以使用Generator和yield配合setInterval来进行实现。</h5><a id="more"></a><h4 id="3-动图展示"><a href="#3-动图展示" class="headerlink" title="3.动图展示"></a>3.动图展示</h4><p><img src="\img\js\maopao.gif" alt="图1"></p><h4 id="4-部分代码"><a href="#4-部分代码" class="headerlink" title="4.部分代码"></a>4.部分代码</h4><p>使用的vue框架，完整代码在 <a href="https://github.com/Qian4321/sort-v" target="_blank" rel="noopener">https://github.com/Qian4321/sort-v</a></p><pre><code>const bubble = function* (array) {  let length = array.length;  for (let i = 0; i &lt; length; i++) {    for (let j = 0; j &lt; length - 1-i; j++) {      if (array[j] &gt; array[j + 1]) {        [array[j], array[j + 1]] = [array[j + 1], array[j]];        yield array;      }    }  }}export default bubble;</code></pre><p>调用代码：</p><pre><code>bubble_click(){    let chart = bar.myChart(&quot;main&quot;);    let option = bar.option;    let array = bubble([60, 89, 23, 78, 36,42,72,19,49,73,48]);    let arr;    option.title.text = &quot;冒泡排序&quot;;   let dosort= setInterval(() =&gt; {     arr = array.next();     if (arr.done == true) {       clearInterval(dosort);       return;     }     option.xAxis.data = arr.value;     option.series[0].data = arr.value;     chart.setOption(option);   }, 500)  }</code></pre><h3 id="三-选择排序"><a href="#三-选择排序" class="headerlink" title="三.选择排序"></a>三.选择排序</h3><h4 id="1-选择排序主要思想也是通过双层for循环，与冒泡不同的是他不会将相邻的项交换位置，而是直接间接交换最大值或最小值到指定的位置。复杂度也是O-n-2-。"><a href="#1-选择排序主要思想也是通过双层for循环，与冒泡不同的是他不会将相邻的项交换位置，而是直接间接交换最大值或最小值到指定的位置。复杂度也是O-n-2-。" class="headerlink" title="1.选择排序主要思想也是通过双层for循环，与冒泡不同的是他不会将相邻的项交换位置，而是直接间接交换最大值或最小值到指定的位置。复杂度也是O(n^2)。"></a>1.选择排序主要思想也是通过双层for循环，与冒泡不同的是他不会将相邻的项交换位置，而是直接间接交换最大值或最小值到指定的位置。复杂度也是O(n^2)。</h4><h4 id="2-代码实现-1"><a href="#2-代码实现-1" class="headerlink" title="2.代码实现"></a>2.代码实现</h4><h5 id="与冒泡类似"><a href="#与冒泡类似" class="headerlink" title="与冒泡类似"></a>与冒泡类似</h5><h4 id="3-动图展示-1"><a href="#3-动图展示-1" class="headerlink" title="3.动图展示"></a>3.动图展示</h4><p><img src="\img\js\selection.gif" alt="图2"></p><h4 id="4-部分代码-1"><a href="#4-部分代码-1" class="headerlink" title="4.部分代码"></a>4.部分代码</h4><pre><code>const selection = function* (array) {  let length = array.length;  for (let i = 0; i &lt; length - 1; i++) {    let max = array[0];    let index = 0;    for (let j = 1; j &lt;= length - 1 - i; j++) {      if (array[j] &gt; max) {        max = array[j];        index = j;      }    }    [array[index], array[length - 1 - i]] = [array[length - 1 - i], array[index]];    yield array;  }}export default selection;</code></pre><h3 id="四-插入排序"><a href="#四-插入排序" class="headerlink" title="四.插入排序"></a>四.插入排序</h3><h4 id="1-插入排序主要是将数组第一位看成是已经排序好的，然后将后面的项插入到已经排列好的序列中。性能比冒泡和选择要好。"><a href="#1-插入排序主要是将数组第一位看成是已经排序好的，然后将后面的项插入到已经排列好的序列中。性能比冒泡和选择要好。" class="headerlink" title="1.插入排序主要是将数组第一位看成是已经排序好的，然后将后面的项插入到已经排列好的序列中。性能比冒泡和选择要好。"></a>1.插入排序主要是将数组第一位看成是已经排序好的，然后将后面的项插入到已经排列好的序列中。性能比冒泡和选择要好。</h4><h4 id="2-动图展示"><a href="#2-动图展示" class="headerlink" title="2.动图展示"></a>2.动图展示</h4><p><img src="\img\js\insertion.gif" alt="图3"></p><h4 id="3-部分代码"><a href="#3-部分代码" class="headerlink" title="3.部分代码"></a>3.部分代码</h4><pre><code>const insertion = function* (array) {  let length = array.length,      j, temp;  for (let i = 1; i &lt; length; i++) {    j = i;    temp = array[i];    while (j &gt; 0 &amp;&amp; temp &lt; array[j - 1]) {      array[j] = array[j - 1];      j--;    }    array[j] = temp;    yield array;  }}export default insertion;</code></pre>]]></content>
      
      
      <categories>
          
          <category> javascript&amp;es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 可视化 </tag>
            
            <tag> js </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js数据结构-字典和散列表</title>
      <link href="/2019/05/07/js%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8%E5%92%8C%E6%95%A3%E5%88%97%E8%A1%A8/"/>
      <url>/2019/05/07/js%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8%E5%92%8C%E6%95%A3%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="一-字典"><a href="#一-字典" class="headerlink" title="一.字典"></a>一.字典</h3><p>和集合不同的是，字典使用[键，值]的形式来储存值，键是唯一的，也就可以保证储存的是惟一值。ps:字典也被称为映射。在es6中可以用map来进行字典操作。</p><h4 id="1-1创建字典"><a href="#1-1创建字典" class="headerlink" title="1.1创建字典"></a>1.1创建字典</h4><p>字典中包含以下方法(根据es6的Map)：set(key,value)-添加新元素（那为什么不使用add），delete(key)-根据键值删除数据，has(key)-判断键值是否存在于字典中，get(key)-根据键值获取值，clear()-清除所有值，size()-返回元素的数量，keys()-将字典的键值以数组形式返回，values()-将字典的数值以数组形式返回。<br><a id="more"></a></p><h4 id="1-2具体代码"><a href="#1-2具体代码" class="headerlink" title="1.2具体代码"></a>1.2具体代码</h4><pre><code>class Dictionary {  constructor() {    this.items = {};  }  //添加值  set(key, value) {    Reflect.set(this.items, key, value);  }  //判断值是否存在  has(key) {    return Reflect.has(this.items, key);  }  //删除值  delete(key) {    if (this.has(key)) {      Reflect.deleteProperty(this.items, key);      return true;    }    else {      return false;    }  }  //获取值  get(key) {    if (this.has(key)) {      return Reflect.get(this.items, key);    }    else {      return false;    }  }  //清空字典  clear() {    this.items = {};  }  //返回字典长度  size() {    return Reflect.ownKeys(this.items).length;  }  //返回Key数组  keys() {    return Reflect.ownKeys(this.items);  }  //返回所有值  values() {    let keys = this.keys();    let values=[];    for (let key of keys) {      values.push(this.get(key));    }    return values;  }  //打印所有{key,value}  print() {    console.log(&quot;打印所有元素&quot;);    let keys = this.keys();    let values = this.values();    for (let i = 0; i &lt; keys.length;i++ ) {      console.log(&quot;{&quot; + keys[i] + &quot;,&quot; + values[i] + &quot;}&quot;);    }  }}module.exports = Dictionary;</code></pre><p>在这里为了适应es6将很多Object中的函数使用Reflect来代替，其中大多数改变不大，只有in和delete的使用方法有较大改变。具体代码较简单。</p><h3 id="二-散列表"><a href="#二-散列表" class="headerlink" title="二.散列表"></a>二.散列表</h3><p>散列表又名HashTable(HashMap),是Dictionary类的一种散列表实现方式。具体就是将键值装化为一个哈希值，存储在数组对应哈希值的地方，但有可能会出现哈希冲突，所以需要更多的方法来减小哈希冲突。优势:实现了随机访问，所以性能比较快，但是对于散列函数的设计要求比较高，而且设计需要根据自己的需求进行设计，实现高访问。</p><h4 id="2-1-创建散列表"><a href="#2-1-创建散列表" class="headerlink" title="2.1 创建散列表"></a>2.1 创建散列表</h4><p>散列表的方法较少，put(key.value)-向散列表中添加一个新值，remove(key)-在散列表中移除一个，get(key)-获取值。</p><h4 id="2-2-具体代码"><a href="#2-2-具体代码" class="headerlink" title="2.2 具体代码"></a>2.2 具体代码</h4><pre><code>class HashTable {  constructor() {    this.table = [];    //获取key的哈希值,ps:要尽量减少冲突    this.loseloseHashCode = function (key) {      let hash = 0;      for (let char of key) {        hash =char.charCodeAt();      }      return hash % 37;    }  }  //添加元素  put(key, value) {    let hash = this.loseloseHashCode(key);    this.table[hash] = value;  }  //移除元素  remove(key) {    let hash = this.loseloseHashCode(key);    this.table[hash] = undefined;  }  //获取值  get(key) {    let hash = this.loseloseHashCode(key);    return this.table[hash];  }}module.exports = HashTable;</code></pre><p>回忆：for..of循环可以使用的范围包括数组，Set和Map结构，某些类似数组的对象，Generator对象，以及字符串。但上面的代码会很容易出现Hash冲突，即hash的值很容易一样，这样就会导致后添加的值替换前面的，出现错误。</p><h4 id="2-3-处理哈希冲突的三种方法"><a href="#2-3-处理哈希冲突的三种方法" class="headerlink" title="2.3 处理哈希冲突的三种方法"></a>2.3 处理哈希冲突的三种方法</h4><h5 id="2-3-1-分离链接"><a href="#2-3-1-分离链接" class="headerlink" title="2.3.1 分离链接"></a>2.3.1 分离链接</h5><p>通过前面学习的链表，将hash值对应的数组位置指向一个链表的head,然后若出现重复的hash值就直接将值挂靠到链表后面。</p><h5 id="2-3-2-线性探查"><a href="#2-3-2-线性探查" class="headerlink" title="2.3.2 线性探查"></a>2.3.2 线性探查</h5><p>将出现重复的哈希值依次瞬移到空白的位置，个人感觉很蠢。</p><h5 id="2-3-3-创建更好的散列函数"><a href="#2-3-3-创建更好的散列函数" class="headerlink" title="2.3.3 创建更好的散列函数"></a>2.3.3 创建更好的散列函数</h5><pre><code>this.loseloseHashCode = function (key) {  let hash = 5381;//常用质数  for (let char of key) {    hash =hash*33+char.charCodeAt();  }  return hash % 1031;}</code></pre><p>这是改良后的生成哈希值的算法，虽然我不懂原理，但这只是降低了出现冲突的概率，并不能完全消灭。</p>]]></content>
      
      
      <categories>
          
          <category> js数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 字典 </tag>
            
            <tag> 散列表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js数据结构--链表</title>
      <link href="/2019/05/06/js%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/05/06/js%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="一-链表数据结构"><a href="#一-链表数据结构" class="headerlink" title="一.链表数据结构"></a>一.链表数据结构</h3><pre><code>链表储存有序的元素集合，但不同于数组，链表中的元素在内存中不是连续放置的。每个元素有一个储存元素本身的节点和指向下一个元素的引用组成。</code></pre><p><img src="\img\DataStructures\链表1_1.png" alt="图1.1 来自百度百科"></p><h3 id="二-创建链表"><a href="#二-创建链表" class="headerlink" title="二.创建链表"></a>二.创建链表</h3><p>在这里采用es6的class语法糖进行创建LinkedList类，该类包含append方法–向链表中添加元素到末尾，insert方法–向链表中插入一个元素，remove方法–移除一个元素，indexof方法–返回元素在列表中的属性，removeAt–从链表中移除特定位置的一项，isEmpty–看链表是否为空，size–获取链表长度。<br><a id="more"></a></p><h4 id="1-整体框架"><a href="#1-整体框架" class="headerlink" title="1.整体框架"></a>1.整体框架</h4><pre><code>class LinkedList {  constructor() {    this.length = 0;//标识链表的长度    this.head = null;//标识头结点    this.node = function (element) {      this.element = element;      this.next = null;     }   }   //具体方法...   append(element) {}   insert(position,element){}   //还有许多方法... }</code></pre><p>在类的构造函数内定义基本变量，其中定义了一个node类，目的是将传入的元素储存在其中，并与next属性相绑定。</p><h4 id="2-append方法"><a href="#2-append方法" class="headerlink" title="2.append方法"></a>2.append方法</h4><p>在创建append方法前，要考虑链表是否为空的情况，若为空，则直接添加，若不为空，则遍历链表将其放置到末尾。</p><pre><code>//向链表中添加元素append(element) {  let node =new this.node(element);  let current;//一个用于遍历的中间变量  if (this.length == 0) {    this.head = node;//如果链表为空，则将添加的node设置为头结点  }  else {    current = this.head;    while (current.next) {//找到最后的子节点        current = current.next;    }    current.next = node;  }    this.length++;}</code></pre><h4 id="3-insert方法"><a href="#3-insert方法" class="headerlink" title="3.insert方法"></a>3.insert方法</h4><p>insert方法有两个参数，一个是要插入的位置，一个是要插入的元素。过于插入的位置从0开始，若为0则插入到最前面，以此类推。在插入时首先要根据进行position的判断，看是否越界。对于position是否为0也要有对于的处理方法。</p><pre><code>//向列表中插入元素insert(position,element) {  if (position &gt;= 0 &amp;&amp; position &lt; this.length) {    let node = new this.node(element);    let index = 1;    let current;    //添加到首部    if (position == 0) {      node.next = this.head;      this.head = node;    }    else {      current = this.head;      while (index++ &lt; position) {        current = current.next;      }      node.next = current.next;      current.next = node;      }      this.length++;    }else {    return false;   }}</code></pre><h4 id="4-remove方法"><a href="#4-remove方法" class="headerlink" title="4.remove方法"></a>4.remove方法</h4><p>实现remove方法要先判断该元素是否存在，由于可能出现重复的情况，所以只删掉离head最近的元素。</p><pre><code>//从列表中移除元素,移除对应element出现第一次的node,后面的重复不管，若要移除全部，可配合indexof方法进行删除remove(element) {  let current = this.head;  let exit = false;//判断该element是否存在  while (current.next) {    if (current.next.element == element) {      exit = true;      break;    }    current = current.next;  }  if (exit == true) {    if (current.next.next == null) {//为null说明被删除元素是最后一个      current.next = null;    }    else {      current.next = current.next.next;    }  }  else {    return false;  }  this.length--;}</code></pre><h4 id="5-indexof方法"><a href="#5-indexof方法" class="headerlink" title="5.indexof方法"></a>5.indexof方法</h4><p>同样有可能出现重复的元素情况，所以若查找的元素存在就返回离head最近的index,若不存在就返回-1。</p><pre><code>//返回元素的索引,若不存在则返回-1,索引从0开始indexof(element) {  let current = this.head;  let index = 0;  while (current.next) {//这种判断方法忽略了最后一个node    if (current.element == element) {      return index;    }    index++;    current = current.next;  }  //判断最后一个node  if (current.element == element) {    return length - 1;  }  else {//若最后一个元素都不满足条件，则可判断不存在这个元素    return -1;  }}</code></pre><h4 id="6-print方法"><a href="#6-print方法" class="headerlink" title="6.print方法"></a>6.print方法</h4><p>该方法是打印出所有node的element属性。</p><pre><code>//打印所有成员print() {  if (this.length == 0) {    console.log(&quot;链表长度为0&quot;)  }  else {    let current = this.head    while (current.next) {      console.log(current.element);      current = current.next;    }    console.log(current.element);  }}</code></pre><h4 id="7-其他方法就简单，只贴代码"><a href="#7-其他方法就简单，只贴代码" class="headerlink" title="7.其他方法就简单，只贴代码"></a>7.其他方法就简单，只贴代码</h4><pre><code>//判断该链表是否为空,直接判断head是否为空isEmpty() {  if (this.head) {    return true;  }  else {    return false;  }}//返回链表长度size() {  return this.length;}</code></pre><h3 id="三-测试"><a href="#三-测试" class="headerlink" title="三.测试"></a>三.测试</h3><p>将类模块导出去，然后在主代码里运行。</p><pre><code>//测试数据结构const Linked = require(&apos;./LinkedList/Linked&apos;);let mylink = new Linked();mylink.print();mylink.append(1);mylink.append(2);mylink.append(3);mylink.print();console.log(&quot;插入&quot;)mylink.insert(2, 99);mylink.print();console.log(&quot;移除&quot;)mylink.remove(2);mylink.remove(99);mylink.print();console.log(&quot;获取长度&quot;);console.log(mylink.size());console.log(&quot;获取索引&quot;);console.log(mylink.indexof(3));console.log(&quot;获取长度&quot;);console.log(mylink.size());</code></pre><p>结果如下图：<br><img src="\img\DataStructures\链表1_2.jpg" alt="图1.2"></p>]]></content>
      
      
      <categories>
          
          <category> js数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js阶段学习（二）</title>
      <link href="/2019/04/28/js%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2019/04/28/js%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="二-函数上下文和-amp-执行上下文-amp-作用域"><a href="#二-函数上下文和-amp-执行上下文-amp-作用域" class="headerlink" title="二.函数上下文和&amp;执行上下文&amp;作用域"></a>二.函数上下文和&amp;执行上下文&amp;作用域</h2><h3 id="1-函数上下文"><a href="#1-函数上下文" class="headerlink" title="1.函数上下文"></a>1.函数上下文</h3><p>函数上下文就是常见的this,this的值是可变的，在调用函数的时候才能确定this的值。而函数的调用也很多种方式，对应的this取值规则也都不一样。<br><a id="more"></a></p><h4 id="1-1-通过函数直接调用"><a href="#1-1-通过函数直接调用" class="headerlink" title="1.1 通过函数直接调用"></a>1.1 通过函数直接调用</h4><p>无论是函数声明还是函数表达式，如果是作为函数被直接调用，那么它的函数上下文是windows,在严格模式下是undefined。</p><h4 id="1-2-作为方法被调用"><a href="#1-2-作为方法被调用" class="headerlink" title="1.2 作为方法被调用"></a>1.2 作为方法被调用</h4><p>当函数被当做对象的属性被调用时，此时的函数上下文指的就是调用函数对象。</p><h4 id="1-3-作为构造函数调用"><a href="#1-3-作为构造函数调用" class="headerlink" title="1.3 作为构造函数调用"></a>1.3 作为构造函数调用</h4><p>1）构造函数如果返回的是非对象类型，则直接忽略返回值，将创建得函数作为函数上下文。<br>2）构造函数返回的是对象，则将返回的对象作为整个表达式的值返回，传入的this无效。</p><h4 id="1-4-使用apply和call方法调用"><a href="#1-4-使用apply和call方法调用" class="headerlink" title="1.4 使用apply和call方法调用"></a>1.4 使用apply和call方法调用</h4><p>apply和call方法都是定义在Function方法的原型对象中，所以普通的方法也可以使用。apply和call可以自己选择传入一个对象作为函数上下文。</p><h4 id="1-5-使用箭头函数忽略this"><a href="#1-5-使用箭头函数忽略this" class="headerlink" title="1.5 使用箭头函数忽略this"></a>1.5 使用箭头函数忽略this</h4><p>调用箭头函数时，不会传入this参数，而是从定义时函数继承上下文。</p><h3 id="2-执行上下文"><a href="#2-执行上下文" class="headerlink" title="2.执行上下文"></a>2.执行上下文</h3><p>在js中，代码的执行基础单元是函数，每当发生函数调用，都会出现执行上下文的改变。全局代码对应的是全局执行上下文，函数代码对应的是执行上下文。当代码开始运行时，首先将全局执行上下文入栈（调用栈），调用其他函数后将该函数入栈，全局执行上下文暂停，运行该函数的执行上下文。按此规律，所有函数进行入栈出栈。</p><h3 id="3-作用域（语法环境）"><a href="#3-作用域（语法环境）" class="headerlink" title="3.作用域（语法环境）"></a>3.作用域（语法环境）</h3><p>在执行上下文入栈的时候，会创建一个与之对应的作用域环境，并在该函数的内置[[Environment]]属性上与上一个入栈的作用域环境。</p>]]></content>
      
      
      <categories>
          
          <category> javascript&amp;es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js阶段学习（一）</title>
      <link href="/2019/04/26/js%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2019/04/26/js%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一-面向对象"><a href="#一-面向对象" class="headerlink" title="一.面向对象"></a>一.面向对象</h2><h3 id="1-闭包"><a href="#1-闭包" class="headerlink" title="1.闭包"></a>1.闭包</h3><pre><code>闭包的作用在我看来就是将创建的函数对象包裹起来，有着独立的变量，作用域，并且保护函数中的变量。接近c#中的对象概念，每个对象之间都是独立的。闭包的具体作用大概可以有两种：1)封装私有变量：js不支持私有变量，但可以在函数中声明变量，来达到一个类似私有变量的效果。2）就是类似对象，可以很好的使用一个函数生成许多实例，并且实例互不影响，达到代码复用。</code></pre><a id="more"></a><h3 id="2-原型链"><a href="#2-原型链" class="headerlink" title="2.原型链"></a>2.原型链</h3><pre><code>首先知道js中对象都是有函数产生的，而函数是一种特殊的对象。所以就有一个叫Function的函数它自己生成了自己。所有的对象都有一个叫_proto_的隐藏属性，该属性指向生成该函数的原型对象。所以Function函数的_proto_属性指向的是自己的原型对象。而其他函数都是由Function函数生成的，所以它们的_proto_属性指向的也是Function的原型对象。那既然函数是由Function函数生成的，对象便是由Object函数生成的。这个Object函数是由Function函数生成的，所以它的_proto_属性指向也就是Function函数对应的原型。而这个Object函数的作用就是生成出来函数的对象。前面说到每个对象都有_proto_属性指向生成函数的原型对象，既然是对象，那么它也有属于自己的_proto_属性。因为对象是由Object函数生成的，所以的_proto_属性指向的就是Object函数的原型对象，而Object函数的原型对象就指向null。这样通过_proto_属性就构成了原型链。</code></pre><h3 id="3-继承"><a href="#3-继承" class="headerlink" title="3.继承"></a>3.继承</h3><pre><code>各个对象之间是由_proto_进行串联起来的。比如利用构造函数Function创建了一个普通对象obj1，那么该对象的_proto_指向构造函数的原型对象。而该原型对象的_proto_就指向Object函数的原型对象，然后指向null。所以通过继承可以在这个新建的普通函数中使用构造函数的原型对象的方法和Object函数的原型对象的方法。这是本来就有的继承。所以如果再定义一个对象obj2来继承前面写的obj1对象，那么就只需要将obj2的构造函数的原型对象设置为obj1，便可以通过原型链访问到obj1中的方法和obj1的_proto_中的方法。但需要注意的是，应该要让在改变obj2的构造函数的propotype指向obj1后，obj1的constructor属性也要指向obj2的构造函数。</code></pre><p>下面是反应函数与对象之间关系的图：<br><img src="\img\js\继承关系.png" alt="js"><br>图片来源：<a href="https://www.cnblogs.com/wangfupeng1988/p/3979533.html" target="_blank" rel="noopener">https://www.cnblogs.com/wangfupeng1988/p/3979533.html</a></p>]]></content>
      
      
      <categories>
          
          <category> javascript&amp;es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack arcgis api for js</title>
      <link href="/2019/03/18/webpack-arcgis-api-for-js/"/>
      <url>/2019/03/18/webpack-arcgis-api-for-js/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;将arcgis api for js 与webpack结合起来对于我来说确实比较难，但其中dojo也要承担大部分的责任。arcgis api for js采用dojo进行开发，但我感觉dojo也快不行了，在webpack中水土不服。估计Esri也感觉不好意思，开发了esri-loader来进行辅助。这里采用的也是esri-loader。<br><a id="more"></a></p><h2 id="一-使用步骤"><a href="#一-使用步骤" class="headerlink" title="一.使用步骤"></a>一.使用步骤</h2><h3 id="1-安装依赖包"><a href="#1-安装依赖包" class="headerlink" title="1.安装依赖包"></a>1.安装依赖包</h3><ul><li>esri-loader(关键包)</li><li>express(框架)</li><li>http-proxy-middleware(node来处理跨域的包，究极好用)</li><li><p>babel全家桶(处理es6代码)</p><h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;在webpack的entry文件中导入esri-loader包。</p><p> import esriLoader from ‘esri-loader’;<br>然后加载在线的js api和css文件，这里建议将js api 布置在本地，避免一些不必要的麻烦。关于将js api布置在本地可以参考这一篇博客：<a href="https://blog.csdn.net/qq_35117024/article/details/82633084" target="_blank" rel="noopener">本地部署</a>。部署完了可以参考以下代码加载</p><p> esriLoader.loadCss(‘<a href="http://127.0.0.1:3001/arcgis_js_api/library/4.9/esri/css/main.css&#39;)" target="_blank" rel="noopener">http://127.0.0.1:3001/arcgis_js_api/library/4.9/esri/css/main.css&#39;)</a>;<br> const options = {<br>  url:’<a href="http://127.0.0.1:3001/arcgis_js_api/library/4.9/dojo/dojo.js&#39;" target="_blank" rel="noopener">http://127.0.0.1:3001/arcgis_js_api/library/4.9/dojo/dojo.js&#39;</a><br> };<br>加载完毕后就可以进行开发了。</p><h3 id="3-开发"><a href="#3-开发" class="headerlink" title="3.开发"></a>3.开发</h3><h4 id="3-1-js部分代码"><a href="#3-1-js部分代码" class="headerlink" title="3.1 js部分代码"></a>3.1 js部分代码</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;代码如下：</p></li></ul><pre><code>&gt;加载函数&gt;esriLoader.loadModules([    &quot;esri/Map&quot;,    &quot;esri/Ground&quot;,    &quot;esri/layers/ElevationLayer&quot;,    &quot;esri/config&quot;,    &quot;esri/views/SceneView&quot;,    &quot;esri/geometry/Extent&quot;,    &quot;dojo/domReady&quot;],options)    .then(([Map,Ground,ElevationLayer,esriConfig,SceneView,Extent]) =&gt; {        esriConfig.request.corsEnabledServers.push(&quot;localhost:6080&quot;);//设   置地图服务器已允许跨域        var customElevation = ElevationLayer({            url: &quot;http://localhost:6080/arcgis/rest/services//SiChuan/suining/MapServer&quot;        });        var map = new Map({            // basemap: &quot;streets&quot;,//ESRI提供的底 图            basemap: &quot;hybrid&quot;,//ESRI提供的影像图            //  ground: &quot;world-elevation&quot;//ESRI提供的全球地形            ground: new Ground({                layers: [ customElevation ]            })        });        var view=new SceneView({            map:map,            container: &quot;viewDiv&quot;        });        view.ui.remove(&quot;attribution&quot;);//移除底部ESRI logo        view.when(function () {            view.goTo({                position: {                    x: 113.642578125,                    y: 34.7222900390625,                    z: 700,                    spatialReference: {                        wkid: 4326                    }                },                heading: 50,                tilt: 80            }, {                speedFactor: 0.7            });        }).catch(function (reason) {            console.log(reason)    })}).catch(err =&gt; {// handle any script or module loading errorsconsole.error(err);});</code></pre><p>可以看出它的使用代码和原始的使用方法差不多，只是有一些加载上的不同。然后就可以愉快的打包了。</p><h4 id="3-2-html部分代码"><a href="#3-2-html部分代码" class="headerlink" title="3.2 html部分代码"></a>3.2 html部分代码</h4><pre><code>&gt; &lt;!DOCTYPE html&gt;&gt; &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt;    &lt;title&gt;第一个地图应用&lt;/title&gt;    &lt;style&gt;    html,    body,    #viewDiv {    padding: 0;    margin: 0;    height: 100%;    width: 100%;    }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;script src=&quot;/javascripts/bundle.js&quot;&gt;&lt;/script&gt;    &lt;div id=&quot;viewDiv&quot; &gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>Tips:注意这里的id和css代码，别搞错了。bundle.js是打包生成的文件，要放在boby标签里。</p><h4 id="3-3-关于跨域的问题"><a href="#3-3-关于跨域的问题" class="headerlink" title="3.3 关于跨域的问题"></a>3.3 关于跨域的问题</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;我开始也是想在布置本地api的时候就按照网上的解决方法设置跨域，但弄了很久，经历了从入门到放弃。然后决定直接在后端进行转发，而使用node.js的express的中间件http-proxy-middleware就十分方便了。这个中间件的用处十分强大，在这里就只使用它的一小部分功能。</p><pre><code>let app = express();let proxy = require(&apos;http-proxy-middleware&apos;);let apiProxyJs = proxy({target: &apos;http://192.168.0.104/&apos;,changeOrigin : true});app.use(&apos;/arcgis_js_api&apos;, apiProxyJs);</code></pre><p>大概意思就是请求的url里面路径是’/arcgis_js_api’开头的，都改变它的主机。我这里就的http请求是’<a href="http://127.0.0.1:3001/arcgis_js_api/library/4.9/dojo/dojo.js&#39;，经过转发就是&#39;http://http://192.168.0.104/arcgis_js_api/library/4.9/dojo/dojo.js&#39;。使用的时候要变成自己的路径。" target="_blank" rel="noopener">http://127.0.0.1:3001/arcgis_js_api/library/4.9/dojo/dojo.js&#39;，经过转发就是&#39;http://http://192.168.0.104/arcgis_js_api/library/4.9/dojo/dojo.js&#39;。使用的时候要变成自己的路径。</a><br>(完结撒花)</p>]]></content>
      
      
      <categories>
          
          <category> arcgis api for js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
            <tag> webgis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我</title>
      <link href="/2019/03/17/%E6%88%91/"/>
      <url>/2019/03/17/%E6%88%91/</url>
      
        <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="Welcome to my blog, enter password to read." />    <label for="pass">Welcome to my blog, enter password to read.</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>R语言空间信息挖掘（三）</title>
      <link href="/2019/03/16/R%E8%AF%AD%E8%A8%80%E7%A9%BA%E9%97%B4%E4%BF%A1%E6%81%AF%E6%8C%96%E6%8E%98%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2019/03/16/R%E8%AF%AD%E8%A8%80%E7%A9%BA%E9%97%B4%E4%BF%A1%E6%81%AF%E6%8C%96%E6%8E%98%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="一-实验要求"><a href="#一-实验要求" class="headerlink" title="一.实验要求"></a>一.实验要求</h3><pre><code>经过前面的学习，我觉得我可以完成老师所布置的第一次作业了。这次的作业要求大概如下：老师提供csv文件，其中格式为</code></pre><table><thead><tr><th>uid</th><th>gpa</th><th>4月1日</th><th>4月2日</th></tr></thead><tbody><tr><td>15</td><td>3.45</td><td>34</td><td>37</td></tr><tr><td>18</td><td>2.45</td><td></td><td>33</td></tr></tbody></table><a id="more"></a><pre><code>大致意思就是记录该学号(uid)在某天某节课上课时坐的位置编号，gpa为成绩。实验的目的就是通过可视化计算出gpa比较好的同学在教室里是聚集分布还是均匀分布或是随机分布。</code></pre><h3 id="二-实验思路"><a href="#二-实验思路" class="headerlink" title="二.实验思路"></a>二.实验思路</h3><h4 id="1-导入数据，进行数据的预处理，即是将本节课没有来的同学去除掉。"><a href="#1-导入数据，进行数据的预处理，即是将本节课没有来的同学去除掉。" class="headerlink" title="1.导入数据，进行数据的预处理，即是将本节课没有来的同学去除掉。"></a>1.导入数据，进行数据的预处理，即是将本节课没有来的同学去除掉。</h4><h4 id="2-进行数据处理，将座位编号转化为在二维上的点坐标。"><a href="#2-进行数据处理，将座位编号转化为在二维上的点坐标。" class="headerlink" title="2.进行数据处理，将座位编号转化为在二维上的点坐标。"></a>2.进行数据处理，将座位编号转化为在二维上的点坐标。</h4><h4 id="3-将生成的二维坐标与uid-gpa联系起来生成SpatialPointDataFrame。"><a href="#3-将生成的二维坐标与uid-gpa联系起来生成SpatialPointDataFrame。" class="headerlink" title="3.将生成的二维坐标与uid,gpa联系起来生成SpatialPointDataFrame。"></a>3.将生成的二维坐标与uid,gpa联系起来生成SpatialPointDataFrame。</h4><h4 id="4-将SpatialPointDataFrame转化为SpatialPixelsDataFrame，然后进行绘图。"><a href="#4-将SpatialPointDataFrame转化为SpatialPixelsDataFrame，然后进行绘图。" class="headerlink" title="4.将SpatialPointDataFrame转化为SpatialPixelsDataFrame，然后进行绘图。"></a>4.将SpatialPointDataFrame转化为SpatialPixelsDataFrame，然后进行绘图。</h4><h4 id="5-分别采用样方法和聚类法进行分析。"><a href="#5-分别采用样方法和聚类法进行分析。" class="headerlink" title="5.分别采用样方法和聚类法进行分析。"></a>5.分别采用样方法和聚类法进行分析。</h4><h3 id="三-具体实验步骤-代码"><a href="#三-具体实验步骤-代码" class="headerlink" title="三.具体实验步骤(代码)"></a>三.具体实验步骤(代码)</h3><h4 id="1-定义变量，便于后期修改数据"><a href="#1-定义变量，便于后期修改数据" class="headerlink" title="1.定义变量，便于后期修改数据"></a>1.定义变量，便于后期修改数据</h4><pre><code>library(sp)#定义变量xnum&lt;-10#每行有多少个座位bestgpa&lt;-3#定义多少gpa为优秀学生date&lt;-&quot;X4月11日&quot;#定义截取的日期</code></pre><h4 id="2-读取数据，过滤数据"><a href="#2-读取数据，过滤数据" class="headerlink" title="2.读取数据，过滤数据"></a>2.读取数据，过滤数据</h4><pre><code>#读取数据data=read.csv(&quot;F:/google下载/seat.csv&quot;,header=TRUE)#读取数据fdata=data[c(&quot;uid&quot;,&quot;gpa.all&quot;,date)]#选取4月9日的数据fdata=fdata[complete.cases(fdata),]#过滤数据为NA的行</code></pre><p>获取seat.csv文件的链接链接：<a href="https://pan.baidu.com/s/16XKNH-uGwOEyV1E1gcLpgA" target="_blank" rel="noopener">https://pan.baidu.com/s/16XKNH-uGwOEyV1E1gcLpgA</a> ,提取码：osc4 </p><h4 id="3-创建SpatialPixelsDataFrame"><a href="#3-创建SpatialPixelsDataFrame" class="headerlink" title="3.创建SpatialPixelsDataFrame"></a>3.创建SpatialPixelsDataFrame</h4><pre><code>#创建SpatialPointsseat&lt;-fdata[3]#获取座位编号num&lt;-nrow(seat)#获取需要创建的座位个数seat1&lt;-coordinates(cbind(x=seat[(1:num),1]%%xnum+1,y=seat[(1:num),1]%/%xnum+1))#生成座位seat2&lt;-SpatialPoints(seat1)seat3&lt;-SpatialPointsDataFrame(seat2,fdata[c(&quot;gpa.all&quot;)])seat4&lt;-as(seat3,&quot;SpatialPixelsDataFrame&quot;)#强制转化为SpatialPixelsDataFramespplot(subset(seat4,gpa.all&gt;=bestgpa))</code></pre><p>最后一行spplot中的过滤条件改变bestgpa来改变展示的座位。<br><img src="\img\R与空间分析_img\3-1.jpeg" alt="图3.1"></p><h4 id="4-样方法分析"><a href="#4-样方法分析" class="headerlink" title="4.样方法分析"></a>4.样方法分析</h4><h5 id="4-1-划定样方大小"><a href="#4-1-划定样方大小" class="headerlink" title="4.1 划定样方大小"></a>4.1 划定样方大小</h5><pre><code>生成图为10X8的大小，可以划分为2X2的区域，也可以有其他的划分方法。这也是样方的缺点之一，样方的确定对实验结果的影响特别大。</code></pre><h5 id="4-2-计算均值与方差"><a href="#4-2-计算均值与方差" class="headerlink" title="4.2 计算均值与方差"></a>4.2 计算均值与方差</h5><pre><code>规则：对于均匀分布，方差=0，因此VMR的期望值= 0；对于随机分布，方差=均值，因此VMR的期望值= 1；对于聚集分布，方差大于均值。因此VMR的期望值 &gt;1 #样方法的计算，样方大小为2X2,本次实验采取手工读数，不采取包的方式area&lt;-c(2,1,0,1,0,0,0,1,0,1,2,0,2,0,1,2,1,2,2,1)#每个2x2方格中优秀的个数mean &lt;- mean(area)#平均值var&lt;-var(area)#方差VMR&lt;-var/mean# 0.7174515可大致判断为好学生在教室是随机分布的</code></pre><h4 id="5-核密度估计-相比样方法更合理一点"><a href="#5-核密度估计-相比样方法更合理一点" class="headerlink" title="5.核密度估计(相比样方法更合理一点)"></a>5.核密度估计(相比样方法更合理一点)</h4><h5 id="5-1处理数据，选取带宽，但由于带宽太大不好算，所以在不导入第三方包的情况下选择1为带宽。"><a href="#5-1处理数据，选取带宽，但由于带宽太大不好算，所以在不导入第三方包的情况下选择1为带宽。" class="headerlink" title="5.1处理数据，选取带宽，但由于带宽太大不好算，所以在不导入第三方包的情况下选择1为带宽。"></a>5.1处理数据，选取带宽，但由于带宽太大不好算，所以在不导入第三方包的情况下选择1为带宽。</h5><pre><code>#核密度方法DK&lt;-1#定义带宽cd&lt;-merge(1:10,1:8)cd&lt;-cbind(cd,v=0)#添加一行存储该座位上是不是好学生，初始为0，不是好学生seat5&lt;-cbind(x=seat[(1:num),1]%%xnum+1,y=seat[(1:num),1]%/%xnum+1)seat6&lt;-cbind(seat5,fdata[2])#生成数据框for(i in 1:num){      #print(seat6[i,])      for(p in 1:80){         if(seat6[i,][,1]==cd[p,][,1]&amp;seat6[i,][,2]==cd[p,][,2]&amp;seat6[i,][,3]&gt;=bestgpa)         {            cd[p,][,3]=1         }      }}#进行核密度算法，获取指定带宽周围有多少个好学生for(p in 1:80){      x=cd[p,][,1]      y=cd[p,][,2]      v=cd[p,][,3]      for(i in 1:80){         if(x==cd[i,][,1]&amp;y+1==cd[i,][,2]){            v=v+cd[i,][,3]         }         if(x-1==cd[i,][,1]&amp;y==cd[i,][,2]){            v=v+cd[i,][,3]         }         if(x+1==cd[i,][,1]&amp;y-1==cd[i,][,2]){            v=v+cd[i,][,3]         }         if(x+1==cd[i,][,1]&amp;y==cd[i,][,2]){            v=v+cd[i,][,3]         }         if(x==cd[i,][,1]&amp;y-1==cd[i,][,2]){            v=v+cd[i,][,3]         }         if(x-1==cd[i,][,1]&amp;y+1==cd[i,][,2]){            v=v+cd[i,][,3]         }         if(x+1==cd[i,][,1]&amp;y+1==cd[i,][,2]){            v=v+cd[i,][,3]         }         if(x-1==cd[i,][,1]&amp;y-1==cd[i,][,2]){            v=v+cd[i,][,3]         }         cd[p,][,4]=v      }   }#将cd转化为空间点或网格并展示cds&lt;-coordinates(cd[1:2])sp&lt;-SpatialPointsDataFrame(cds,cd[4])sp1&lt;-as(sp,&quot;SpatialPixelsDataFrame&quot;)#强制转化为SpatialPixelsDataFramerw.colors&lt;-colorRampPalette(c(&quot;grey&quot;,&quot;red&quot;))spplot(sp1,col.regions=rw.colors(17))#绘制核密度图形</code></pre><p>   最终结果如下图所示：<br>   <img src="\img\R与空间分析_img\3-5-1.jpeg" alt="图3-5-1 核聚类展示"></p>]]></content>
      
      
      <categories>
          
          <category> R语言空间信息挖掘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R语言 </tag>
            
            <tag> 数据挖掘 </tag>
            
            <tag> gis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R语言空间信息挖掘（二）</title>
      <link href="/2019/03/16/R%E8%AF%AD%E8%A8%80%E7%A9%BA%E9%97%B4%E4%BF%A1%E6%81%AF%E6%8C%96%E6%8E%98%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2019/03/16/R%E8%AF%AD%E8%A8%80%E7%A9%BA%E9%97%B4%E4%BF%A1%E6%81%AF%E6%8C%96%E6%8E%98%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一-空间数据可视化"><a href="#一-空间数据可视化" class="headerlink" title="一.空间数据可视化"></a>一.空间数据可视化</h2><pre><code>R语言有两个绘图系统：传统绘图系统和lattice程序包提供的Trellis绘图系统，目前R语言默认安装了这个程序包。SP包提供了增强传统R语言绘图系统的plot方法，以及一个使用Trellis系统(特别是lattice包中的xyplot或levelplot)并能够用于条件绘图的名为spplot的新通用方法。</code></pre><h3 id="1-传统绘图系统"><a href="#1-传统绘图系统" class="headerlink" title="1.传统绘图系统"></a>1.传统绘图系统</h3><h4 id="1-1绘制点、线、多边形、和网格"><a href="#1-1绘制点、线、多边形、和网格" class="headerlink" title="1.1绘制点、线、多边形、和网格"></a>1.1绘制点、线、多边形、和网格</h4><a id="more"></a><pre><code>在接下来的例子中，从sp程序包中通过data函数获得data.frame对象，并从data.frame对象创建点、线、多边形以及网格对象并绘制图形。&gt; library(sp)&gt; data(&quot;meuse&quot;)&gt; coordinates(meuse)&lt;-c(&quot;x&quot;,&quot;y&quot;)&gt; plot(meuse)结果如下图所示：</code></pre><p><img src="\img\R与空间分析_img\2-1-1.jpg" alt="图1.1.1 点"></p><pre><code>&gt; library(sp)&gt; data(&quot;meuse&quot;)&gt; coordinates(meuse)&lt;-c(&quot;x&quot;,&quot;y&quot;)&gt; cc&lt;- coordinates(meuse)&gt; line&lt;-Line(cc)&gt; lines&lt;-Lines(line,ID=&quot;a&quot;)&gt; m.s1&lt;-SpatialLines(list(lines))&gt; plot(m.s1)&gt; title(&quot;Lines&quot;)结果如下图所示：</code></pre><p><img src="\img\R与空间分析_img\2-1-2.jpg" alt="图1.1.2 线"></p><pre><code>&gt; library(sp)&gt; data(&quot;meuse&quot;)&gt; data(&quot;meuse.riv&quot;)&gt; meuse.lst&lt;-list(Polygons(list(Polygon(meuse.riv)),&quot;meuse.riv&quot;))&gt; meuse.sr&lt;-SpatialPolygons(meuse.lst)&gt; plot(meuse.sr,col=&quot;red&quot;)&gt; title(&quot;polygons&quot;)结果如下图所示：</code></pre><p><img src="\img\R与空间分析_img\2-1-3.jpg" alt="图1.1.3 多边形"></p><pre><code>&gt; library(sp)&gt; data(&quot;meuse.grid&quot;)&gt; coordinates(meuse.grid)&lt;-c(&quot;x&quot;,&quot;y&quot;)&gt; meuse.grid&lt;-as(meuse.grid,&quot;SpatialPixels&quot;)&gt;image(meuse.grid,col=&quot;green&quot;)&gt;title(&quot;grid&quot;)结果如下图所示：</code></pre><p><img src="\img\R与空间分析_img\2-1-4.jpg" alt="图1.1.4 网格"></p><h4 id="1-2-布局元素"><a href="#1-2-布局元素" class="headerlink" title="1.2 布局元素"></a>1.2 布局元素</h4><pre><code>可以使用axes=TRUE为图添加坐标轴，也还可以添加比例尺和指北针......</code></pre><h4 id="1-3-绘图属性和地图图例"><a href="#1-3-绘图属性和地图图例" class="headerlink" title="1.3 绘图属性和地图图例"></a>1.3 绘图属性和地图图例</h4><table><thead><tr><th>类名</th><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>SpatialLinesDataFrame</td><td>col</td><td>颜色</td></tr><tr><td></td><td>lwd</td><td>线宽</td></tr><tr><td></td><td>lty</td><td>线类型</td></tr><tr><td>SpatialPolygonsDataFrame</td><td>border</td><td>边框颜色</td></tr><tr><td></td><td>density</td><td>散列密度</td></tr><tr><td></td><td>angle</td><td>散列角度</td></tr><tr><td></td><td>lty</td><td>线类型</td></tr><tr><td></td><td>pgb</td><td>孔颜色</td></tr><tr><td>SpatialPointsDataFrame</td><td>pch</td><td>符号</td></tr><tr><td></td><td>col</td><td>颜色</td></tr><tr><td></td><td>bg</td><td>填充颜色</td></tr><tr><td></td><td>cex</td><td>符号尺寸</td></tr><tr><td>SpatialPixelsDataFrame和SpatialGridDataFrame</td><td>zlim</td><td>符号属性值</td></tr><tr><td></td><td>col</td><td>颜色</td></tr><tr><td></td><td>breaks</td><td>断点</td></tr></tbody></table><h4 id="1-4-根据实际例子学习"><a href="#1-4-根据实际例子学习" class="headerlink" title="1.4.根据实际例子学习"></a>1.4.根据实际例子学习</h4><h5 id="1-4-1可视化SpatialPointsDataFrame"><a href="#1-4-1可视化SpatialPointsDataFrame" class="headerlink" title="1.4.1可视化SpatialPointsDataFrame"></a>1.4.1可视化SpatialPointsDataFrame</h5><pre><code>&gt; library(sp)&gt; cd&lt;-coordinates(merge(1:10,1:10))&gt; da&lt;-data.frame(da=1:100)&gt; sp1&lt;-SpatialPointsDataFrame(cd,da)&gt; plot(sp1,pch=15,col=cols)</code></pre><p>注意将向量转化为矩阵的rbind(),cbind(),merge()方法的区别。这里运用的就是普通的plot方法。<br><img src="\img\R与空间分析_img\2-2-1.jpg" alt="图1.4.1 空间点可视化"></p><h5 id="1-4-2可视化SpatialGridDataFrame"><a href="#1-4-2可视化SpatialGridDataFrame" class="headerlink" title="1.4.2可视化SpatialGridDataFrame"></a>1.4.2可视化SpatialGridDataFrame</h5><pre><code>&gt;library(sp)&gt;gd&lt;-GridTopology(cellcentre.offset = c(1,1), cellsize=c(1,1), cells.dim = c(8,9))&gt;SpG&lt;-SpatialGrid(gd)&gt;da&lt;-data.frame(da=1:72)&gt;SpGF&lt;-SpatialGridDataFrame(SpG,da)&gt;plot(SpGF,zlim=c(0,100))</code></pre><p>注意这里生成SpatialGrid只需要了grid，而不需要SpatialPoints,通过getClass(SpG)可以看见SpatialPoints。<br><img src="\img\R与空间分析_img\2-2-2.jpg" alt="图1.4.2 空间网格可视化"></p><h3 id="2-使用Spplot的Trellis-Lattice绘制"><a href="#2-使用Spplot的Trellis-Lattice绘制" class="headerlink" title="2.使用Spplot的Trellis/Lattice绘制"></a>2.使用Spplot的Trellis/Lattice绘制</h3><pre><code>Spplot与plot的优势是对于带有空间数据的属性，对于条件绘图的支持度很好。缺点是对于注释和图例等处理比较麻烦</code></pre><h4 id="2-1根据实际例子学习"><a href="#2-1根据实际例子学习" class="headerlink" title="2.1根据实际例子学习"></a>2.1根据实际例子学习</h4><h5 id="2-1-1-将1-4中的例子分别用spplot代替plot-得到下面的结果："><a href="#2-1-1-将1-4中的例子分别用spplot代替plot-得到下面的结果：" class="headerlink" title="2.1.1 将1.4中的例子分别用spplot代替plot,得到下面的结果："></a>2.1.1 将1.4中的例子分别用spplot代替plot,得到下面的结果：</h5><p><img src="\img\R与空间分析_img\2-2-2-2.jpg" alt="图2.1.1.1 空间点可视化"></p><p><img src="\img\R与空间分析_img\2-2-2-3.jpg" alt="图2.1.2.2 空间网格可视化"></p><h5 id="2-1-2-条件绘图"><a href="#2-1-2-条件绘图" class="headerlink" title="2.1.2 条件绘图"></a>2.1.2 条件绘图</h5><pre><code>将网格可视化的&lt; da&lt;-data.frame(da=1:72)改为&lt; da&lt;-data.frame(da=1:72,da1=72:1)即增加一行属性数据，使用spplot绘图得到如下结果</code></pre><p><img src="\img\R与空间分析_img\2-2-2-4.jpg" alt="图2.1.2 spplot空间网格可视化"><br>    可以与plot创造的图像有明显优势。</p>]]></content>
      
      
      <categories>
          
          <category> R语言空间信息挖掘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R语言 </tag>
            
            <tag> 数据挖掘 </tag>
            
            <tag> gis </tag>
            
            <tag> 可视化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R语言空间信息挖掘（一）</title>
      <link href="/2019/03/15/R%E8%AF%AD%E8%A8%80%E7%A9%BA%E9%97%B4%E4%BF%A1%E6%81%AF%E6%8C%96%E6%8E%98%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2019/03/15/R%E8%AF%AD%E8%A8%80%E7%A9%BA%E9%97%B4%E4%BF%A1%E6%81%AF%E6%8C%96%E6%8E%98%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一-R语言空间信息挖掘简介"><a href="#一-R语言空间信息挖掘简介" class="headerlink" title="一.R语言空间信息挖掘简介"></a>一.R语言空间信息挖掘简介</h2><pre><code>R系统是一款基于统计计算和绘图的免费软件。R系统提供了许多标准的和创新的统计分析方法。在过去的10年，R语言拥有越来越多用于处理和分析空间数据的包。其中一组R开发者实现了R包sp,它新增的用于空间数据的类和方法扩展了R的功能。sp包提供了点、线、多边形和网格的类和方法，采用单组空间数据类有许多重要的优势。本实验就是基于sp包进行。</code></pre><a id="more"></a><h2 id="二-空间数据的类型"><a href="#二-空间数据的类型" class="headerlink" title="二.空间数据的类型"></a>二.空间数据的类型</h2><pre><code>空间数据有空间坐标值以及这些坐标的参照系。具体在sp包中如下：</code></pre><blockquote><ul><li>点：一个单点位置，比如全球定位系统读取的位置或地理编码；</li><li>线：有序点的集合，由直线段相连；</li><li>多边行：一个区域，由一条或以上的封闭线组成，可能含孔；</li><li>网格：点或矩形单元的集合，由<strong>规则的栅格</strong>构成。</li></ul></blockquote><pre><code>前三个是矢量数据，表示尽量精准的实体，而最后一个数据模型是栅格数据模型，表示使用规则单元铺盖的连续表面。所有的空间数据包含位置信息，可以说明位置在哪里。</code></pre><h2 id="三-R的空间数据类"><a href="#三-R的空间数据类" class="headerlink" title="三.R的空间数据类"></a>三.R的空间数据类</h2><h3 id="1-Spatial对象"><a href="#1-Spatial对象" class="headerlink" title="1.Spatial对象"></a>1.Spatial对象</h3><pre><code>    Spatial类是基类，只有两个槽(槽被指定为类中所包含成员的表示方法)，第一个是约束盒，它是一个数值坐标矩阵，拥有列名为c(&apos;min&apos;,&apos;max&apos;)的数值坐标，至少有两行，即x-轴，y-轴。第二个是定义类坐标参考的CRS类对象，默认值为NA(缺失值)。可以使用getClass方法来获取类的完整定义，包括槽的名字及其内容和类型：&gt;library(sp)&gt;getClass(&quot;Spatial&quot;)Class &quot;Spatial&quot; [package &quot;sp&quot;]Slots:Name: bbox    proj4stringClass:matrix  CRS这里的Name和Class应该是上下对应的关系。所以要创建一个Spatial类的方法：&gt; s&lt;-Spatial(bbox=m,proj4string=crs)这里的m和crs就是对应的matrix(矩阵)和CRS类(创建crs类同理可根据getClass(&quot;CRS&quot;)看参数创建)。bbox为边界。</code></pre><h3 id="2-SpatialPoints类"><a href="#2-SpatialPoints类" class="headerlink" title="2.SpatialPoints类"></a>2.SpatialPoints类</h3><pre><code>SpatialPoints类是Spatial类的第一个子类。通过使用getClass(&quot;SpatialPoints&quot;)可以看出SpatialPoints类比Spatial多了一个coords槽(坐标)，扩展后可以插入坐标矩阵。</code></pre><h4 id="2-1-方法"><a href="#2-1-方法" class="headerlink" title="2.1 方法"></a>2.1 方法</h4><pre><code>方法用来访问Spatial对象的值。</code></pre><blockquote><ul><li>bbox(<em>SpatialPoints</em>)获取空间点的边界</li><li>proj4string(<em>SpatialPoints</em>)获取或设置投影</li><li>coordinates(<em>SpatialPoints</em>)获取坐标矩阵，可以进行索引筛选。</li></ul></blockquote><h4 id="2-2-空间点数据的数据框"><a href="#2-2-空间点数据的数据框" class="headerlink" title="2.2 空间点数据的数据框"></a>2.2 空间点数据的数据框</h4><pre><code>SpatialPointDataFrame的构成如下图所示（2-2）。</code></pre><p><img src="\img\R与空间分析_img\2-2.jpg" alt="图2-2"></p><pre><code>这个类扩展了SpatialPoints，继承了Spatial类对象所包含的信息。在一个data.frame对象中数据框信息保存在data槽中。</code></pre><h3 id="3-SpatialLines和SpatialPolygons"><a href="#3-SpatialLines和SpatialPolygons" class="headerlink" title="3.SpatialLines和SpatialPolygons"></a>3.SpatialLines和SpatialPolygons</h3><pre><code>关于这两个类与SpatialPoints类相似，其组成如图3所示</code></pre><p><img src="\img\R与空间分析_img\3.jpg" alt="图3"></p>]]></content>
      
      
      <categories>
          
          <category> R语言空间信息挖掘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R语言 </tag>
            
            <tag> 数据挖掘 </tag>
            
            <tag> gis </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
