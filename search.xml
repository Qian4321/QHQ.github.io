<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>R语言空间信息挖掘（三）</title>
      <link href="/2019/03/16/R%E8%AF%AD%E8%A8%80%E7%A9%BA%E9%97%B4%E4%BF%A1%E6%81%AF%E6%8C%96%E6%8E%98%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2019/03/16/R%E8%AF%AD%E8%A8%80%E7%A9%BA%E9%97%B4%E4%BF%A1%E6%81%AF%E6%8C%96%E6%8E%98%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="一-实验要求"><a href="#一-实验要求" class="headerlink" title="一.实验要求"></a>一.实验要求</h3><pre><code>经过前面的学习，我觉得我可以完成老师所布置的第一次作业了。这次的作业要求大概如下：老师提供csv文件，其中格式为</code></pre><table><thead><tr><th>uid</th><th>gpa</th><th>4月1日</th><th>4月2日</th></tr></thead><tbody><tr><td>15</td><td>3.45</td><td>34</td><td>37</td></tr><tr><td>18</td><td>2.45</td><td></td><td>33</td></tr></tbody></table><pre><code>大致意思就是记录该学号(uid)在某天某节课上课时坐的位置编号，gpa为成绩。实验的目的就是通过可视化计算出gpa比较好的同学在教室里是聚集分布还是均匀分布或是随机分布。</code></pre><h3 id="二-实验思路"><a href="#二-实验思路" class="headerlink" title="二.实验思路"></a>二.实验思路</h3><h4 id="1-导入数据，进行数据的预处理，即是将本节课没有来的同学去除掉。"><a href="#1-导入数据，进行数据的预处理，即是将本节课没有来的同学去除掉。" class="headerlink" title="1.导入数据，进行数据的预处理，即是将本节课没有来的同学去除掉。"></a>1.导入数据，进行数据的预处理，即是将本节课没有来的同学去除掉。</h4><h4 id="2-进行数据处理，将座位编号转化为在二维上的点坐标。"><a href="#2-进行数据处理，将座位编号转化为在二维上的点坐标。" class="headerlink" title="2.进行数据处理，将座位编号转化为在二维上的点坐标。"></a>2.进行数据处理，将座位编号转化为在二维上的点坐标。</h4><h4 id="3-将生成的二维坐标与uid-gpa联系起来生成SpatialPointDataFrame。"><a href="#3-将生成的二维坐标与uid-gpa联系起来生成SpatialPointDataFrame。" class="headerlink" title="3.将生成的二维坐标与uid,gpa联系起来生成SpatialPointDataFrame。"></a>3.将生成的二维坐标与uid,gpa联系起来生成SpatialPointDataFrame。</h4><h4 id="4-将SpatialPointDataFrame转化为SpatialPixelsDataFrame，然后进行绘图。"><a href="#4-将SpatialPointDataFrame转化为SpatialPixelsDataFrame，然后进行绘图。" class="headerlink" title="4.将SpatialPointDataFrame转化为SpatialPixelsDataFrame，然后进行绘图。"></a>4.将SpatialPointDataFrame转化为SpatialPixelsDataFrame，然后进行绘图。</h4><h4 id="5-分别采用样方法和聚类法进行分析。"><a href="#5-分别采用样方法和聚类法进行分析。" class="headerlink" title="5.分别采用样方法和聚类法进行分析。"></a>5.分别采用样方法和聚类法进行分析。</h4><h3 id="三-具体实验步骤-代码"><a href="#三-具体实验步骤-代码" class="headerlink" title="三.具体实验步骤(代码)"></a>三.具体实验步骤(代码)</h3><h4 id="1-定义变量，便于后期修改数据"><a href="#1-定义变量，便于后期修改数据" class="headerlink" title="1.定义变量，便于后期修改数据"></a>1.定义变量，便于后期修改数据</h4><pre><code>library(sp)#定义变量xnum&lt;-10#每行有多少个座位bestgpa&lt;-3#定义多少gpa为优秀学生date&lt;-&quot;X4月11日&quot;#定义截取的日期</code></pre><h4 id="2-读取数据，过滤数据"><a href="#2-读取数据，过滤数据" class="headerlink" title="2.读取数据，过滤数据"></a>2.读取数据，过滤数据</h4><pre><code>#读取数据data=read.csv(&quot;F:/google下载/seat.csv&quot;,header=TRUE)#读取数据fdata=data[c(&quot;uid&quot;,&quot;gpa.all&quot;,date)]#选取4月9日的数据fdata=fdata[complete.cases(fdata),]#过滤数据为NA的行</code></pre><p>获取seat.csv文件的链接链接：<a href="https://pan.baidu.com/s/16XKNH-uGwOEyV1E1gcLpgA" target="_blank" rel="noopener">https://pan.baidu.com/s/16XKNH-uGwOEyV1E1gcLpgA</a> ,提取码：osc4 </p><h4 id="3-创建SpatialPixelsDataFrame"><a href="#3-创建SpatialPixelsDataFrame" class="headerlink" title="3.创建SpatialPixelsDataFrame"></a>3.创建SpatialPixelsDataFrame</h4><pre><code>#创建SpatialPointsseat&lt;-fdata[3]#获取座位编号num&lt;-nrow(seat)#获取需要创建的座位个数seat1&lt;-coordinates(cbind(x=seat[(1:num),1]%%xnum+1,y=seat[(1:num),1]%/%xnum+1))#生成座位seat2&lt;-SpatialPoints(seat1)seat3&lt;-SpatialPointsDataFrame(seat2,fdata[c(&quot;gpa.all&quot;)])seat4&lt;-as(seat3,&quot;SpatialPixelsDataFrame&quot;)#强制转化为SpatialPixelsDataFramespplot(subset(seat4,gpa.all&gt;=bestgpa))</code></pre><p>最后一行spplot中的过滤条件改变bestgpa来改变展示的座位。<br><img src="\img\R与空间分析_img\3-1.jpeg" alt="图3.1"></p><h4 id="4-样方法分析"><a href="#4-样方法分析" class="headerlink" title="4.样方法分析"></a>4.样方法分析</h4><h5 id="4-1-划定样方大小"><a href="#4-1-划定样方大小" class="headerlink" title="4.1 划定样方大小"></a>4.1 划定样方大小</h5><pre><code>生成图为10X8的大小，可以划分为2X2的区域，也可以有其他的划分方法。这也是样方的缺点之一，样方的确定对实验结果的影响特别大。</code></pre><h5 id="4-2-计算均值与方差"><a href="#4-2-计算均值与方差" class="headerlink" title="4.2 计算均值与方差"></a>4.2 计算均值与方差</h5><pre><code>规则：对于均匀分布，方差=0，因此VMR的期望值= 0；对于随机分布，方差=均值，因此VMR的期望值= 1；对于聚集分布，方差大于均值。因此VMR的期望值 &gt;1 #样方法的计算，样方大小为2X2,本次实验采取手工读数，不采取包的方式area&lt;-c(2,1,0,1,0,0,0,1,0,1,2,0,2,0,1,2,1,2,2,1)#每个2x2方格中优秀的个数mean &lt;- mean(area)#平均值var&lt;-var(area)#方差VMR&lt;-var/mean# 0.7174515可大致判断为好学生在教室是随机分布的</code></pre><h4 id="5-核密度估计-相比样方法更合理一点"><a href="#5-核密度估计-相比样方法更合理一点" class="headerlink" title="5.核密度估计(相比样方法更合理一点)"></a>5.核密度估计(相比样方法更合理一点)</h4><h5 id="5-1处理数据，选取带宽，但由于带宽太大不好算，所以在不导入第三方包的情况下选择1为带宽。"><a href="#5-1处理数据，选取带宽，但由于带宽太大不好算，所以在不导入第三方包的情况下选择1为带宽。" class="headerlink" title="5.1处理数据，选取带宽，但由于带宽太大不好算，所以在不导入第三方包的情况下选择1为带宽。"></a>5.1处理数据，选取带宽，但由于带宽太大不好算，所以在不导入第三方包的情况下选择1为带宽。</h5><pre><code>#核密度方法DK&lt;-1#定义带宽cd&lt;-merge(1:10,1:8)cd&lt;-cbind(cd,v=0)#添加一行存储该座位上是不是好学生，初始为0，不是好学生seat5&lt;-cbind(x=seat[(1:num),1]%%xnum+1,y=seat[(1:num),1]%/%xnum+1)seat6&lt;-cbind(seat5,fdata[2])#生成数据框for(i in 1:num){      #print(seat6[i,])      for(p in 1:80){         if(seat6[i,][,1]==cd[p,][,1]&amp;seat6[i,][,2]==cd[p,][,2]&amp;seat6[i,][,3]&gt;=bestgpa)         {            cd[p,][,3]=1         }      }}#进行核密度算法，获取指定带宽周围有多少个好学生for(p in 1:80){      x=cd[p,][,1]      y=cd[p,][,2]      v=cd[p,][,3]      for(i in 1:80){         if(x==cd[i,][,1]&amp;y+1==cd[i,][,2]){            v=v+cd[i,][,3]         }         if(x-1==cd[i,][,1]&amp;y==cd[i,][,2]){            v=v+cd[i,][,3]         }         if(x+1==cd[i,][,1]&amp;y-1==cd[i,][,2]){            v=v+cd[i,][,3]         }         if(x+1==cd[i,][,1]&amp;y==cd[i,][,2]){            v=v+cd[i,][,3]         }         if(x==cd[i,][,1]&amp;y-1==cd[i,][,2]){            v=v+cd[i,][,3]         }         if(x-1==cd[i,][,1]&amp;y+1==cd[i,][,2]){            v=v+cd[i,][,3]         }         if(x+1==cd[i,][,1]&amp;y+1==cd[i,][,2]){            v=v+cd[i,][,3]         }         if(x-1==cd[i,][,1]&amp;y-1==cd[i,][,2]){            v=v+cd[i,][,3]         }         cd[p,][,4]=v      }   }#将cd转化为空间点或网格并展示cds&lt;-coordinates(cd[1:2])sp&lt;-SpatialPointsDataFrame(cds,cd[4])sp1&lt;-as(sp,&quot;SpatialPixelsDataFrame&quot;)#强制转化为SpatialPixelsDataFramerw.colors&lt;-colorRampPalette(c(&quot;grey&quot;,&quot;red&quot;))spplot(sp1,col.regions=rw.colors(17))#绘制核密度图形</code></pre><p>   最终结果如下图所示：<br>   <img src="\img\R与空间分析_img\3-5-1.jpg" alt="图3-5-1 空间网格可视化"></p>]]></content>
      
      
      <categories>
          
          <category> R语言空间信息挖掘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R语言 </tag>
            
            <tag> 数据挖掘 </tag>
            
            <tag> gis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R语言空间信息挖掘（二）</title>
      <link href="/2019/03/16/R%E8%AF%AD%E8%A8%80%E7%A9%BA%E9%97%B4%E4%BF%A1%E6%81%AF%E6%8C%96%E6%8E%98%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2019/03/16/R%E8%AF%AD%E8%A8%80%E7%A9%BA%E9%97%B4%E4%BF%A1%E6%81%AF%E6%8C%96%E6%8E%98%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一-空间数据可视化"><a href="#一-空间数据可视化" class="headerlink" title="一.空间数据可视化"></a>一.空间数据可视化</h2><pre><code>R语言有两个绘图系统：传统绘图系统和lattice程序包提供的Trellis绘图系统，目前R语言默认安装了这个程序包。SP包提供了增强传统R语言绘图系统的plot方法，以及一个使用Trellis系统(特别是lattice包中的xyplot或levelplot)并能够用于条件绘图的名为spplot的新通用方法。</code></pre><h3 id="1-传统绘图系统"><a href="#1-传统绘图系统" class="headerlink" title="1.传统绘图系统"></a>1.传统绘图系统</h3><h4 id="1-1绘制点、线、多边形、和网格"><a href="#1-1绘制点、线、多边形、和网格" class="headerlink" title="1.1绘制点、线、多边形、和网格"></a>1.1绘制点、线、多边形、和网格</h4><a id="more"></a><pre><code>在接下来的例子中，从sp程序包中通过data函数获得data.frame对象，并从data.frame对象创建点、线、多边形以及网格对象并绘制图形。&gt; library(sp)&gt; data(&quot;meuse&quot;)&gt; coordinates(meuse)&lt;-c(&quot;x&quot;,&quot;y&quot;)&gt; plot(meuse)结果如下图所示：</code></pre><p><img src="\img\R与空间分析_img\2-1-1.jpg" alt="图1.1.1 点"></p><pre><code>&gt; library(sp)&gt; data(&quot;meuse&quot;)&gt; coordinates(meuse)&lt;-c(&quot;x&quot;,&quot;y&quot;)&gt; cc&lt;- coordinates(meuse)&gt; line&lt;-Line(cc)&gt; lines&lt;-Lines(line,ID=&quot;a&quot;)&gt; m.s1&lt;-SpatialLines(list(lines))&gt; plot(m.s1)&gt; title(&quot;Lines&quot;)结果如下图所示：</code></pre><p><img src="\img\R与空间分析_img\2-1-2.jpg" alt="图1.1.2 线"></p><pre><code>&gt; library(sp)&gt; data(&quot;meuse&quot;)&gt; data(&quot;meuse.riv&quot;)&gt; meuse.lst&lt;-list(Polygons(list(Polygon(meuse.riv)),&quot;meuse.riv&quot;))&gt; meuse.sr&lt;-SpatialPolygons(meuse.lst)&gt; plot(meuse.sr,col=&quot;red&quot;)&gt; title(&quot;polygons&quot;)结果如下图所示：</code></pre><p><img src="\img\R与空间分析_img\2-1-3.jpg" alt="图1.1.3 多边形"></p><pre><code>&gt; library(sp)&gt; data(&quot;meuse.grid&quot;)&gt; coordinates(meuse.grid)&lt;-c(&quot;x&quot;,&quot;y&quot;)&gt; meuse.grid&lt;-as(meuse.grid,&quot;SpatialPixels&quot;)&gt;image(meuse.grid,col=&quot;green&quot;)&gt;title(&quot;grid&quot;)结果如下图所示：</code></pre><p><img src="\img\R与空间分析_img\2-1-4.jpg" alt="图1.1.4 网格"></p><h4 id="1-2-布局元素"><a href="#1-2-布局元素" class="headerlink" title="1.2 布局元素"></a>1.2 布局元素</h4><pre><code>可以使用axes=TRUE为图添加坐标轴，也还可以添加比例尺和指北针......</code></pre><h4 id="1-3-绘图属性和地图图例"><a href="#1-3-绘图属性和地图图例" class="headerlink" title="1.3 绘图属性和地图图例"></a>1.3 绘图属性和地图图例</h4><table><thead><tr><th>类名</th><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>SpatialLinesDataFrame</td><td>col</td><td>颜色</td></tr><tr><td></td><td>lwd</td><td>线宽</td></tr><tr><td></td><td>lty</td><td>线类型</td></tr><tr><td>SpatialPolygonsDataFrame</td><td>border</td><td>边框颜色</td></tr><tr><td></td><td>density</td><td>散列密度</td></tr><tr><td></td><td>angle</td><td>散列角度</td></tr><tr><td></td><td>lty</td><td>线类型</td></tr><tr><td></td><td>pgb</td><td>孔颜色</td></tr><tr><td>SpatialPointsDataFrame</td><td>pch</td><td>符号</td></tr><tr><td></td><td>col</td><td>颜色</td></tr><tr><td></td><td>bg</td><td>填充颜色</td></tr><tr><td></td><td>cex</td><td>符号尺寸</td></tr><tr><td>SpatialPixelsDataFrame和SpatialGridDataFrame</td><td>zlim</td><td>符号属性值</td></tr><tr><td></td><td>col</td><td>颜色</td></tr><tr><td></td><td>breaks</td><td>断点</td></tr></tbody></table><h4 id="1-4-根据实际例子学习"><a href="#1-4-根据实际例子学习" class="headerlink" title="1.4.根据实际例子学习"></a>1.4.根据实际例子学习</h4><h5 id="1-4-1可视化SpatialPointsDataFrame"><a href="#1-4-1可视化SpatialPointsDataFrame" class="headerlink" title="1.4.1可视化SpatialPointsDataFrame"></a>1.4.1可视化SpatialPointsDataFrame</h5><pre><code>&gt; library(sp)&gt; cd&lt;-coordinates(merge(1:10,1:10))&gt; da&lt;-data.frame(da=1:100)&gt; sp1&lt;-SpatialPointsDataFrame(cd,da)&gt; plot(sp1,pch=15,col=cols)</code></pre><p>注意将向量转化为矩阵的rbind(),cbind(),merge()方法的区别。这里运用的就是普通的plot方法。<br><img src="\img\R与空间分析_img\2-2-1.jpg" alt="图1.4.1 空间点可视化"></p><h5 id="1-4-2可视化SpatialGridDataFrame"><a href="#1-4-2可视化SpatialGridDataFrame" class="headerlink" title="1.4.2可视化SpatialGridDataFrame"></a>1.4.2可视化SpatialGridDataFrame</h5><pre><code>&gt;library(sp)&gt;gd&lt;-GridTopology(cellcentre.offset = c(1,1), cellsize=c(1,1), cells.dim = c(8,9))&gt;SpG&lt;-SpatialGrid(gd)&gt;da&lt;-data.frame(da=1:72)&gt;SpGF&lt;-SpatialGridDataFrame(SpG,da)&gt;plot(SpGF,zlim=c(0,100))</code></pre><p>注意这里生成SpatialGrid只需要了grid，而不需要SpatialPoints,通过getClass(SpG)可以看见SpatialPoints。<br><img src="\img\R与空间分析_img\2-2-2.jpg" alt="图1.4.2 空间网格可视化"></p><h3 id="2-使用Spplot的Trellis-Lattice绘制"><a href="#2-使用Spplot的Trellis-Lattice绘制" class="headerlink" title="2.使用Spplot的Trellis/Lattice绘制"></a>2.使用Spplot的Trellis/Lattice绘制</h3><pre><code>Spplot与plot的优势是对于带有空间数据的属性，对于条件绘图的支持度很好。缺点是对于注释和图例等处理比较麻烦</code></pre><h4 id="2-1根据实际例子学习"><a href="#2-1根据实际例子学习" class="headerlink" title="2.1根据实际例子学习"></a>2.1根据实际例子学习</h4><h5 id="2-1-1-将1-4中的例子分别用spplot代替plot-得到下面的结果："><a href="#2-1-1-将1-4中的例子分别用spplot代替plot-得到下面的结果：" class="headerlink" title="2.1.1 将1.4中的例子分别用spplot代替plot,得到下面的结果："></a>2.1.1 将1.4中的例子分别用spplot代替plot,得到下面的结果：</h5><p><img src="\img\R与空间分析_img\2-2-2-2.jpg" alt="图2.1.1.1 空间点可视化"></p><p><img src="\img\R与空间分析_img\2-2-2-3.jpg" alt="图2.1.2.2 空间网格可视化"></p><h5 id="2-1-2-条件绘图"><a href="#2-1-2-条件绘图" class="headerlink" title="2.1.2 条件绘图"></a>2.1.2 条件绘图</h5><pre><code>将网格可视化的&lt; da&lt;-data.frame(da=1:72)改为&lt; da&lt;-data.frame(da=1:72,da1=72:1)即增加一行属性数据，使用spplot绘图得到如下结果</code></pre><p><img src="\img\R与空间分析_img\2-2-2-4.jpg" alt="图2.1.2 spplot空间网格可视化"><br>    可以与plot创造的图像有明显优势。</p>]]></content>
      
      
      <categories>
          
          <category> R语言空间信息挖掘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R语言 </tag>
            
            <tag> 数据挖掘 </tag>
            
            <tag> gis </tag>
            
            <tag> 可视化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R语言空间信息挖掘（一）</title>
      <link href="/2019/03/15/R%E8%AF%AD%E8%A8%80%E7%A9%BA%E9%97%B4%E4%BF%A1%E6%81%AF%E6%8C%96%E6%8E%98%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2019/03/15/R%E8%AF%AD%E8%A8%80%E7%A9%BA%E9%97%B4%E4%BF%A1%E6%81%AF%E6%8C%96%E6%8E%98%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一-R语言空间信息挖掘简介"><a href="#一-R语言空间信息挖掘简介" class="headerlink" title="一.R语言空间信息挖掘简介"></a>一.R语言空间信息挖掘简介</h2><pre><code>R系统是一款基于统计计算和绘图的免费软件。R系统提供了许多标准的和创新的统计分析方法。在过去的10年，R语言拥有越来越多用于处理和分析空间数据的包。其中一组R开发者实现了R包sp,它新增的用于空间数据的类和方法扩展了R的功能。sp包提供了点、线、多边形和网格的类和方法，采用单组空间数据类有许多重要的优势。本实验就是基于sp包进行。</code></pre><a id="more"></a><h2 id="二-空间数据的类型"><a href="#二-空间数据的类型" class="headerlink" title="二.空间数据的类型"></a>二.空间数据的类型</h2><pre><code>空间数据有空间坐标值以及这些坐标的参照系。具体在sp包中如下：</code></pre><blockquote><ul><li>点：一个单点位置，比如全球定位系统读取的位置或地理编码；</li><li>线：有序点的集合，由直线段相连；</li><li>多边行：一个区域，由一条或以上的封闭线组成，可能含孔；</li><li>网格：点或矩形单元的集合，由<strong>规则的栅格</strong>构成。</li></ul></blockquote><pre><code>前三个是矢量数据，表示尽量精准的实体，而最后一个数据模型是栅格数据模型，表示使用规则单元铺盖的连续表面。所有的空间数据包含位置信息，可以说明位置在哪里。</code></pre><h2 id="三-R的空间数据类"><a href="#三-R的空间数据类" class="headerlink" title="三.R的空间数据类"></a>三.R的空间数据类</h2><h3 id="1-Spatial对象"><a href="#1-Spatial对象" class="headerlink" title="1.Spatial对象"></a>1.Spatial对象</h3><pre><code>    Spatial类是基类，只有两个槽(槽被指定为类中所包含成员的表示方法)，第一个是约束盒，它是一个数值坐标矩阵，拥有列名为c(&apos;min&apos;,&apos;max&apos;)的数值坐标，至少有两行，即x-轴，y-轴。第二个是定义类坐标参考的CRS类对象，默认值为NA(缺失值)。可以使用getClass方法来获取类的完整定义，包括槽的名字及其内容和类型：&gt;library(sp)&gt;getClass(&quot;Spatial&quot;)Class &quot;Spatial&quot; [package &quot;sp&quot;]Slots:Name: bbox    proj4stringClass:matrix  CRS这里的Name和Class应该是上下对应的关系。所以要创建一个Spatial类的方法：&gt; s&lt;-Spatial(bbox=m,proj4string=crs)这里的m和crs就是对应的matrix(矩阵)和CRS类(创建crs类同理可根据getClass(&quot;CRS&quot;)看参数创建)。bbox为边界。</code></pre><h3 id="2-SpatialPoints类"><a href="#2-SpatialPoints类" class="headerlink" title="2.SpatialPoints类"></a>2.SpatialPoints类</h3><pre><code>SpatialPoints类是Spatial类的第一个子类。通过使用getClass(&quot;SpatialPoints&quot;)可以看出SpatialPoints类比Spatial多了一个coords槽(坐标)，扩展后可以插入坐标矩阵。</code></pre><h4 id="2-1-方法"><a href="#2-1-方法" class="headerlink" title="2.1 方法"></a>2.1 方法</h4><pre><code>方法用来访问Spatial对象的值。</code></pre><blockquote><ul><li>bbox(<em>SpatialPoints</em>)获取空间点的边界</li><li>proj4string(<em>SpatialPoints</em>)获取或设置投影</li><li>coordinates(<em>SpatialPoints</em>)获取坐标矩阵，可以进行索引筛选。</li></ul></blockquote><h4 id="2-2-空间点数据的数据框"><a href="#2-2-空间点数据的数据框" class="headerlink" title="2.2 空间点数据的数据框"></a>2.2 空间点数据的数据框</h4><pre><code>SpatialPointDataFrame的构成如下图所示（2-2）。</code></pre><p><img src="\img\R与空间分析_img\2-2.jpg" alt="图2-2"></p><pre><code>这个类扩展了SpatialPoints，继承了Spatial类对象所包含的信息。在一个data.frame对象中数据框信息保存在data槽中。</code></pre><h3 id="3-SpatialLines和SpatialPolygons"><a href="#3-SpatialLines和SpatialPolygons" class="headerlink" title="3.SpatialLines和SpatialPolygons"></a>3.SpatialLines和SpatialPolygons</h3><pre><code>关于这两个类与SpatialPoints类相似，其组成如图3所示</code></pre><p><img src="\img\R与空间分析_img\3.jpg" alt="图3"></p>]]></content>
      
      
      <categories>
          
          <category> R语言空间信息挖掘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R语言 </tag>
            
            <tag> 数据挖掘 </tag>
            
            <tag> gis </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
